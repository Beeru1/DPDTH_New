/*****************************************************************************\
 **
 ** Virtualization - Recharge.
 **
 ** Copyright (c) 2007-2008 IBM.
 ** All Rights Reserved
 **
 **
 \****************************************************************************/

package com.ibm.virtualization.recharge.dao.rdbms;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.Logger;

import com.ibm.virtualization.framework.bean.TransactionStatus;
import com.ibm.virtualization.recharge.common.Constants;
import com.ibm.virtualization.recharge.common.ExceptionCode;
import com.ibm.virtualization.recharge.common.RequestType;
import com.ibm.virtualization.recharge.common.TransactionState;
import com.ibm.virtualization.recharge.common.TransactionType;
import com.ibm.virtualization.recharge.common.Utility;
import com.ibm.virtualization.recharge.dao.ReportDao;
import com.ibm.virtualization.recharge.db.DBConnectionManager;
import com.ibm.virtualization.recharge.dto.Account2AccountReport;
import com.ibm.virtualization.recharge.dto.Account2AccountTransferReport;
import com.ibm.virtualization.recharge.dto.CustomerTransaction;
import com.ibm.virtualization.recharge.dto.ReportInputs;
import com.ibm.virtualization.recharge.dto.TransactionReport;
import com.ibm.virtualization.recharge.dto.UserSessionContext;
import com.ibm.virtualization.recharge.exception.DAOException;
import com.ibm.virtualization.recharge.exception.VirtualizationServiceException;
import com.ibm.virtualization.recharge.common.ResourceReader;
/**
 * ReportDaoRdbms is a concrete class that encapsulates data access and
 * manipulation. An implementation of ReportDaoRdbms which is specific to a DB2
 * database.
 * 
 * This class must be package-private, to ensure that the business layer remains
 * unaware of its existence.
 * 
 * @author ashish
 */
public class ReportDaoRdbms extends BaseDaoRdbms implements ReportDao {
	/* logger for this class */
	private static Logger logger = Logger.getLogger(ReportDaoRdbms.class
			.getName());
	

	protected final static String SQL_GENERAL_SELECT_START_CLAUSE_KEY = "SQL_GENERAL_SELECT_START_CLAUSE";

	protected final static String SQL_GENERAL_SELECT_START_CLAUSE = "SELECT * FROM(SELECT a.*,ROW_NUMBER() OVER() rnum FROM (SELECT c.*, COUNT(*) OVER() RECORD_COUNT FROM ( ";

	protected final static String SQL_GENERAL_SELECT_END_CLAUSE_KEY = "SQL_GENERAL_SELECT_END_CLAUSE";

	protected final static String SQL_GENERAL_SELECT_END_CLAUSE = " )c)a)b Where rnum<=? AND rnum>=? ";

	// protected Connection connection = null;
	protected final static String SQL_FETCH_TRAN_SELECT_CLAUSE_KEY = "SQL_FETCH_TRAN_SELECT_CLAUSE";

	protected final static String SQL_FETCH_TRAN_SELECT_CLAUSE = "SELECT COUNT(*) TOTAL_TRANSCTIONS,SUM(TRANS_AMOUNT) TRANSACTION_AMT FROM VR_ACCOUNT_TRANS_REPORT WHERE";
	
	protected final static String SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE_KEY = "SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE";
	
	protected final static String SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE = "SELECT COUNT(*) TOTAL_TRANSCTIONS ";
	
	protected final static String SQL_FETCH_ESP_SELECT_CLAUSE_KEY = "SQL_FETCH_ESP_SELECT_CLAUSE";

	protected final static String SQL_FETCH_ESP_SELECT_CLAUSE ="SELECT	ESPCOMMISSION ";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE = "  DATE(CREATED_DATE) >= ? AND DATE(CREATED_DATE) <= ?";
	
	protected final static String SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY = "SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE";
	
	protected final static String SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE =" FROM VR_RECHARGE_TRANS_REPORT WHERE ";
		
	protected final static String SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY = "SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE";
	
	protected final static String SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE = " FROM VR_POSTPAID_TRANS_REPORT WHERE ";
	
	protected final static String SQL_FETCH_TRAN_FROM_QUERY_CLAUSE_KEY = "SQL_FETCH_TRAN_FROM_QUERY_CLAUSE";
	
	protected final static String SQL_FETCH_TRAN_FROM_QUERY_CLAUSE = "FROM VR_QUERY_TRANS_REPORT WHERE";
	
	protected final static String SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_KEY = "SQL_FETCH_CUST_TRAN_WHERE_CLAUSE";

	protected final static String SQL_FETCH_CUST_TRAN_WHERE_CLAUSE = " REC_CIRCLE_ID=? AND DATE(CREATED_DATE) >= ? AND DATE(CREATED_DATE) <= ?";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER = " AND REQ_CIRCLE_ID = ?";
	
	protected final static String SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY = "SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER";

	protected final static String SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER = " AND CIRCLE_ID = ?";
	
	
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A_KEY= "SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A";
	
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A = " AND REQ_CIRCLE_ID = ?";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER";
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER = " AND UPPER(TRANSFER_ACC_CODE) LIKE ?";
	
	protected final static String SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER_KEY = "SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER";
	protected final static String SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER = " AND UPPER(LOGIN_NAME) LIKE ?";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USRNAME_EXT_USERS_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USRNAME_EXT_USERS";	
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USRNAME_EXT_USERS = "";

	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE";
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE = "";
	
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY = "SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE";
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE = "";


	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS";
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS = "";
	
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY = "SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS";
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS = "";

	protected final static String SQL_ACC2ACC_REPORT_WHERE_CLAUSE_KEY = "SQL_ACC2ACC_REPORT_WHERE_CLAUSE";
   
	
	protected static final String SQL_ACC2ACC_REPORT_WHERE_CLAUSE = " FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN, VR_LOGIN_MASTER LOGIN1, VR_ACCOUNT_DETAILS DETAILS1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID "
			+ "AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND (TDETAIL.TRANS_STATE = "
			+ TransactionState.TRANSFER_REQUEST_LISTENER.getValue()
			+ " OR TDETAIL.TRANS_STATE = "
			+ TransactionState.WEB.getValue()
			+ ")";

	protected final static String SQL_ACC2ACC_REPORT_KEY = "SQL_ACC2ACC_REPORT";

	protected static final String SQL_ACC2ACC_REPORT = "SELECT TRANS.TRANS_ID, TRANS.TRANS_AMOUNT, LOGIN.STATUS, TRANS.TRANS_STATUS, TRANS.CREATED_DATE, TRANS.REQUESTER_ID, DETAILS1.PARENT_ACCOUNT, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE, "
			+ "DETAILS.ACCOUNT_NAME TRANSFER_ACC, DETAILS1.ACCOUNT_NAME RECEIVER_ACC, LOGIN1.LOGIN_NAME RECEIVER_ACC_CODE, DETAILS.CIRCLE_ID, TRANS.RECEIVER_ID, DETAILS1.ACCOUNT_ID, LOGIN.LOGIN_NAME, TRANS.REASON_ID, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT "
			+ SQL_ACC2ACC_REPORT_WHERE_CLAUSE;

	protected final static String SQL_ACC2ACC_COUNT_KEY = "SQL_ACC2ACC_COUNT";

	protected static final String SQL_ACC2ACC_COUNT = "SELECT COUNT(TRANS.TRANS_ID) "
			+ SQL_ACC2ACC_REPORT_WHERE_CLAUSE;

	protected final static String SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE_KEY = "SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE";

	protected static final String SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE = " FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN, VR_ACCOUNT_DETAILS DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID  AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER  AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND (TDETAIL.TRANS_STATE = "
			+ TransactionState.TRANSFER_REQUEST_LISTENER.getValue()
			+ " OR TDETAIL.TRANS_STATE = "
			+ TransactionState.WEB.getValue()
			+ ")";

	protected final static String SQL_TRANSFER_SUMMARY_REPORT_KEY = "SQL_TRANSFER_SUMMARY_REPORT";

	protected static final String SQL_TRANSFER_SUMMARY_REPORT = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, TRANS.TRANS_STATUS, TRANS.TRANS_AMOUNT, TRANS.REQUESTER_ID,DETAILS1.PARENT_ACCOUNT, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE, DETAILS.ACCOUNT_NAME TRANSFER_ACC, DETAILS1.ACCOUNT_NAME RECEIVER_ACC, LOGIN1.LOGIN_NAME  RECEIVER_ACC_CODE, DETAILS.CIRCLE_ID, TRANS.RECEIVER_ID, DETAILS1.ACCOUNT_ID, LOGIN.LOGIN_NAME, TDETAIL.DETAIL_MSG, TRANS.CREATED_DATE "
			+ SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE;

	// For picking up Transaction_Message from Transaction_Details for last
	// entry of transaction detail for a transaction
	// AND TDETAIL.CREATED_DATE = (select max(TDTL1.CREATED_DATE) from
	// VR_TRANS_DETAIL TDTL1 where TDTL1.TRANS_ID = TRANS.TRANS_ID)

	protected final static String SQL_TRANSFER_SUMMARY_COUNT_KEY = "SQL_TRANSFER_SUMMARY_COUNT";

	protected static final String SQL_TRANSFER_SUMMARY_COUNT = "SELECT COUNT(TRANS.TRANS_ID)TOTAL_TRANSCTIONS, SUM(TRANS.TRANS_AMOUNT) TRANSACTION_AMT "
			+ SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE;

	protected final static String SQL_TRANSFER_SUMMARY_CHILD_COUNT_KEY = "SQL_TRANSFER_SUMMARY_CHILD_COUNT";

	protected static final String SQL_TRANSFER_SUMMARY_CHILD_COUNT = "SELECT COUNT(TRANS.TRANS_ID)TOTAL_TRANSCTIONS, SUM(TRANS.TRANS_AMOUNT) TRANSACTION_AMT FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN,VR_CIRCLE_MASTER CIRCLE,  VR_ACCOUNT_DETAILS DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID  AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID  AND DETAILS.CIRCLE_ID = CIRCLE.CIRCLE_ID  AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER  AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID "
			+ " AND TRANS.TRANS_ID = TDETAIL.TRANS_ID  AND TDETAIL.TRANS_STATE = "
			+ TransactionState.TRANSFER_REQUEST_LISTENER.getValue();

	protected final static String SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE_KEY = "SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE";

	protected static final String SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE = "SELECT COUNT(*)TOTAL_TRANSCTIONS, SUM(TRANS.TRANS_AMOUNT) TRANSACTION_AMT FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN,VR_CIRCLE_MASTER CIRCLE,  VR_ACCOUNT_DETAILS DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID  AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID  AND DETAILS.CIRCLE_ID = CIRCLE.CIRCLE_ID  AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER  AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID "
			+ " AND TRANS.TRANS_ID = TDETAIL.TRANS_ID AND DETAILS.ACCOUNT_ID IN ( SELECT ACCOUNT_ID FROM VR_ACCOUNT_DETAILS START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT )";

	protected final static String SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_KEY = "SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT";

	protected static final String SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, TRANS.TRANS_STATUS, TRANS.TRANS_AMOUNT, TRANS.REQUESTER_ID,DETAILS1.PARENT_ACCOUNT, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE, DETAILS.ACCOUNT_NAME TRANSFER_ACC, DETAILS1.ACCOUNT_NAME RECEIVER_ACC, LOGIN1.LOGIN_NAME  RECEIVER_ACC_CODE, DETAILS.CIRCLE_ID, TRANS.RECEIVER_ID, DETAILS1.ACCOUNT_ID, LOGIN.LOGIN_NAME, TDETAIL.DETAIL_MSG, TRANS.CREATED_DATE "
			+ "FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN,VR_CIRCLE_MASTER CIRCLE,  VR_ACCOUNT_DETAILS DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID  AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID  AND DETAILS.CIRCLE_ID = CIRCLE.CIRCLE_ID  AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER  AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND TDETAIL.TRANS_STATE = "
			+ TransactionState.TRANSFER_REQUEST_LISTENER.getValue();

	protected final static String SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE_KEY = "SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE";

	protected static final String SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, TRANS.TRANS_STATUS, TRANS.TRANS_AMOUNT, TRANS.REQUESTER_ID,DETAILS1.PARENT_ACCOUNT, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE, DETAILS.ACCOUNT_NAME TRANSFER_ACC, DETAILS1.ACCOUNT_NAME RECEIVER_ACC, LOGIN1.LOGIN_NAME  RECEIVER_ACC_CODE, DETAILS.CIRCLE_ID, TRANS.RECEIVER_ID, DETAILS1.ACCOUNT_ID, LOGIN.LOGIN_NAME, TDETAIL.DETAIL_MSG, TRANS.CREATED_DATE "
			+ " FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN,VR_CIRCLE_MASTER CIRCLE,  VR_ACCOUNT_DETAILS DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID  AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID  AND DETAILS.CIRCLE_ID = CIRCLE.CIRCLE_ID  AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER  AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND DETAILS.ACCOUNT_ID IN ( SELECT ACCOUNT_ID FROM VR_ACCOUNT_DETAILS START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT )";

	
	
	/*
	 * public static final String SQL_TRANSACTION_REPORT_COUNT = "SELECT
	 * COUNT(*) FROM VR_TRANS_MASTER TRANS , VR_ACCOUNT_DETAILS DETAILS,
	 * VR_LOGIN_MASTER LOGIN,VR_CIRCLE_MASTER CIRCLE, VR_ACCOUNT_DETAILS
	 * DETAILS1, VR_LOGIN_MASTER LOGIN1, VR_TRANS_DETAIL TDETAIL " + " WHERE
	 * TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID =
	 * LOGIN.LOGIN_ID AND DETAILS.CIRCLE_ID = CIRCLE.CIRCLE_ID AND
	 * DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID AND TRANS.TRANS_ID =
	 * TDETAIL.TRANS_ID AND TDETAIL.CREATED_DATE = (select
	 * max(TDTL1.CREATED_DATE) from VR_TRANS_DETAIL TDTL1 where TDTL1.TRANS_ID =
	 * TRANS.TRANS_ID)";
	 */

	protected final static String SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE_KEY = "SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE";

	protected static final String SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE = " FROM VR_TRANS_MASTER TRANS , VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN, VR_TRANS_DETAIL TDETAIL "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 " // for
			// duplicate
			// alias
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   ";

	protected final static String SQL_TRANSACTION_REPORT_COUNT_KEY = "SQL_TRANSACTION_REPORT_COUNT";

	protected static final String SQL_TRANSACTION_REPORT_COUNT = "SELECT COUNT(*) "
			+ SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE;

	// TO BE REPLACED : AND TDETAIL.CREATED_DATE = (select
	// max(TDTL1.CREATED_DATE) from VR_TRANS_DETAIL TDTL1 where TDTL1.TRANS_ID =
	// TRANS.TRANS_ID)
	// WITH : AND TDETAIL.ID =(SELECT ID FROM VR_TRANS_DETAIL TDETAIL1 WHERE
	// TDETAIL1.TRANS_STATE = TransactionState.XXX_REQUEST_LISTENER.getValue()
	// AND TDETAIL1.TRANS_ID = TDETAIL.TRANS_ID )
	// FOR : VAS AND POSTPAID Types of Transaction Reports

	protected final static String SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE_KEY = "SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE";

	protected static final String SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE = " FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   "
			+ " AND DETAILS.ACCOUNT_ID IN ( SELECT ACCOUNT_ID FROM VR_ACCOUNT_DETAILS START WITH ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ) ";

	protected final static String SQL_TRANSACTION_REPORT_CHILD_COUNT_KEY = "SQL_TRANSACTION_REPORT_CHILD_COUNT";

	protected static final String SQL_TRANSACTION_REPORT_CHILD_COUNT = "SELECT COUNT(*) "
			+ SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE;

	protected final static String SQL_TRANSACTION_REPORT_DATA_KEY = "SQL_TRANSACTION_REPORT_DATA";

	protected static final String SQL_TRANSACTION_REPORT_DATA = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, TRANS.REQUESTER_ID, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE , TRANS.RECEIVER_ID , TRANS.TRANS_AMOUNT, TRANS.TRANS_MSG, TRANS.TRANS_DATE, TRANS.TRANS_STATUS, TRANS.REASON_ID, TRANS.CREATED_BY, TDETAIL.DETAIL_MSG, TRANS.TRANS_KEY_VALUE, TRANS.THIRD_PARTY, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT "
			+ SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE;

	protected final static String SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE_KEY = "SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE";

	protected static final String SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE = " FROM VR_TRANS_MASTER TRANS, VR_TRANS_DETAIL TDETAIL , VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID "
			+ "  AND TRANS.TRANS_ID = TDETAIL.TRANS_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND DETAILS1.ACCOUNT_ID = LOGIN1.LOGIN_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID "
			+ " AND DETAILS.ACCOUNT_ID IN ( SELECT ACCOUNT_ID FROM VR_ACCOUNT_DETAILS START WITH ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ) ";

	protected final static String SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_KEY = "SQL_ALL_CHILD_TRANSACTION_REPORT_DATA";

	protected static final String SQL_ALL_CHILD_TRANSACTION_REPORT_DATA = "SELECT TRANS.TRANS_ID,  TRANS.CREATED_BY , TRANS.TRANS_TYPE, TRANS.TRANS_AMOUNT, TRANS.TRANS_STATUS, TRANS.REASON_ID, TRANS.TRANS_MSG, TRANS.TRANS_DATE , TRANS.CREATED_DATE, TRANS.REQUESTER_ID, DETAILS.PARENT_ACCOUNT, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE, TDETAIL.DETAIL_MSG ,"
			+ " DETAILS.ACCOUNT_NAME TRANSFER_ACC, DETAILS1.ACCOUNT_NAME RECEIVER_ACC, LOGIN1.LOGIN_NAME RECEIVER_ACC_CODE, DETAILS.CIRCLE_ID, TRANS.RECEIVER_ID, DETAILS1.ACCOUNT_ID, LOGIN.LOGIN_NAME, TRANS.TRANS_KEY_VALUE, TRANS.THIRD_PARTY, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT "
			+ SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE;

	protected final static String SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_KEY = "SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT";

	protected static final String SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT = " SELECT COUNT(*) TOTAL_TRANSCTIONS,SUM(TRANS.TRANS_AMOUNT) TRANSACTION_AMT  "
			+ " FROM	VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS DETAILS,VR_LOGIN_MASTER LOGIN,	VR_TRANS_DETAIL TDETAIL "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   ";

	protected final static String SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_RECHARGE_KEY = "SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_RECHARGE";

	protected static final String SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_RECHARGE = " SELECT COUNT(*) TOTAL_TRANSCTIONS,SUM(TRANS.TRANS_AMOUNT) TRANSACTION_AMT "
			+ " FROM	VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS DETAILS,VR_LOGIN_MASTER LOGIN,	VR_TRANS_DETAIL TDETAIL "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   ";

	protected final static String SQL_TRANSACTION_SUM_RECHARGE_DATA_KEY = "SQL_TRANSACTION_SUM_RECHARGE_DATA";

	protected static final String SQL_TRANSACTION_SUM_RECHARGE_DATA = " SELECT TRANS.TRANS_ID,TRANS.TRANS_TYPE,TRANS.TRANS_STATUS,TRANS.TRANS_AMOUNT,TRANS.REQUESTER_ID,DETAILS.PARENT_ACCOUNT,LOGIN.LOGIN_NAME TRANSFER_ACC_CODE,DETAILS.ACCOUNT_NAME TRANSFER_ACC,DETAILS.CIRCLE_ID,TRANS.RECEIVER_ID,LOGIN.LOGIN_NAME,TDETAIL.DETAIL_MSG,TRANS.CREATED_DATE "
			+ " FROM	VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS DETAILS,VR_LOGIN_MASTER LOGIN,	VR_TRANS_DETAIL TDETAIL "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   ";

	protected final static String SQL_TRANSACTION_SUM_RECHARGE_DATA_RECHARGE_KEY = "SQL_TRANSACTION_SUM_RECHARGE_DATA_RECHARGE";

	protected static final String SQL_TRANSACTION_SUM_RECHARGE_DATA_RECHARGE = " SELECT TRANS.TRANS_ID,TRANS.TRANS_TYPE,TRANS.TRANS_STATUS,TRANS.TRANS_AMOUNT,TRANS.REQUESTER_ID,DETAILS.PARENT_ACCOUNT,LOGIN.LOGIN_NAME TRANSFER_ACC_CODE,DETAILS.ACCOUNT_NAME TRANSFER_ACC,DETAILS.CIRCLE_ID,TRANS.RECEIVER_ID,LOGIN.LOGIN_NAME,TDETAIL.DETAIL_MSG,TRANS.CREATED_DATE "
			+ " FROM	VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS DETAILS,VR_LOGIN_MASTER LOGIN,	VR_TRANS_DETAIL TDETAIL "
			+ " , VR_LOGIN_MASTER LOGIN1,  VR_ACCOUNT_DETAILS DETAILS1 "
			+ " WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ " AND LOGIN1.LOGIN_ID = DETAILS1.PARENT_ACCOUNT AND  TRANS.REQUESTER_ID = DETAILS1.ACCOUNT_ID   ";
	
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY = "SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE";
	
	protected final static String SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE = "";
	
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY = "SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE";
	protected final static String SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE = "";
	
	/** for A2A transaction 
	 * 
	 * 
	 */
	
//	 protected Connection connection = null;
	protected final static String SQL_FETCH_TRAN_SELECT_A2A_CLAUSE_KEY = "SQL_FETCH_TRAN_SELECT_A2A_CLAUSE";
	protected final static String SQL_FETCH_TRAN_SELECT_A2A_CLAUSE ="SELECT TRANS_ID, TRANS_AMOUNT, LOGIN_STATUS,TRANS_STATUS, CREATED_DATE, REQUESTER_ID, PARENT_ACCOUNT," 
       +" TRANSFER_ACC_CODE, TRANSFER_ACC, RECEIVER_ACC, RECEIVER_ACC_CODE, REQ_CIRCLE_ID, RECEIVER_ID, "
       +" ACCOUNT_ID, TRANSFER_ACC_CODE LOGIN_NAME, REASON_ID, COUNT(TRANS_ID)over() RECORD_COUNT FROM VR_ACCOUNT_TRANS_REPORT ";
	
	protected final static String SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE_KEY = "SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE";
	protected final static String SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE ="SELECT TRANS_ID, TRANS_AMOUNT, LOGIN_STATUS, TRANS_STATUS, CREATED_DATE, REQUESTER_ID, PARENT_ACCOUNT, TRANSFER_ACC_CODE, "
		+"TRANSFER_ACC, RECEIVER_ACC,  RECEIVER_ACC_CODE, REQ_CIRCLE_ID, RECEIVER_ID, ACCOUNT_ID, TRANSFER_ACC_CODE LOGIN_NAME, "
		+"REASON_ID,CREDIT_AMOUNT,DEBIT_AMOUNT,RATE,BALANCE_AFTER_RECHARGE,COUNT(TRANS_ID)over() RECORD_COUNT FROM VR_ACCOUNT_TRANS_REPORT";

	
	protected static final String SQL_FETCH_TRAN_A2A_WHERE_CLAUSE_KEY="SQL_FETCH_TRAN_A2A_WHERE_CLAUSE";
	protected static final String SQL_FETCH_TRAN_A2A_WHERE_CLAUSE = "WHERE DATE(CREATED_DATE) >= ? AND DATE(CREATED_DATE) <= ?"; 

	
	protected static final String SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE_KEY="SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE";
	
	protected static final String SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE = " WHERE DATE(CREATED_DATE) >= ? AND DATE(CREATED_DATE) <= ?";
	
	
	//Query to fetch all transaction Report data 
	
	protected final static String SQL_TRANSACTION_REPORT_DATA_KEY1 = "SQL_TRANSACTION_REPORT_DATA1";

	protected static final String SQL_TRANSACTION_REPORT_DATA1 = "SELECT TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID , TRANS_AMOUNT,"
		+" TRANS_DATE, TRANS_STATUS, REASON_ID,CREATED_BY, TRANS_KEY_VALUE,REQ_MOBILE_NUMBER, PARENT_NAME1, PARENT_NAME2,PARENT_NAME3,PARENT_NAME4,ACCOUNT_ID, COUNT(TRANS_ID)over() RECORD_COUNT ";
	
	//query to fetch transaction report data for ExportToExcel button
				
	protected final static String SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA_KEY = "SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA";

	protected static final String SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA ="SELECT TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID , TRANS_AMOUNT, TRANS_DATE, TRANS_STATUS, "
		+"REASON_ID, CREATED_BY, TRANS_KEY_VALUE, ESPCOMMISSION, SERVICETAX, CREDITEDAMOUNT, DEBITAMOUNT, REQ_CIRCLE_CODE, REC_CIRCLE_CODE, PARENT_NAME1, PARENT_NAME2,PARENT_NAME3,PARENT_NAME4,ACCOUNT_ID,REQ_MOBILE_NUMBER, COUNT(TRANS_ID)over() RECORD_COUNT  ";
	
	//Query to fetch Transaction Report data for View Button
	protected final static String SQL_TRANSACTION_REPORT_VIEW_DATA_KEY = "SQL_TRANSACTION_REPORT_VIEW_DATA";
	

//	protected final static String SQL_TRANSACTION_REPORT_DATA_EXPORT_KEY = "SQL_TRANSACTION_REPORT_DATA_EXPORT";
//
//	protected static final String SQL_TRANSACTION_REPORT_DATA_EXPORT = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, TRANS.REQUESTER_ID, LOGIN.LOGIN_NAME TRANSFER_ACC_CODE , TRANS.RECEIVER_ID , "
//			+"TRANS.TRANS_AMOUNT, TRANS.TRANS_MSG, TRANS.TRANS_DATE, TRANS.TRANS_STATUS, TRANS.REASON_ID, TRANS.CREATED_BY, TRANS.TRANS_KEY_VALUE, TRANS.THIRD_PARTY, "
//			+" COUNT(TRANS.TRANS_ID)over() RECORD_COUNT "
//			+"FROM VR_TRANS_MASTER TRANS , VR_ACCOUNT_DETAILS ACC_DETAILS, VR_LOGIN_MASTER LOGIN, VR_MOBILE_SERIES_CONFIG MOBCONFIG  WHERE ";
//	
	
	protected final static String SQL_CUST_TRAN_REPORT_DATA_KEY = "SQL_CUST_TRAN_REPORT_DATA";

	protected static final String SQL_CUST_TRAN_REPORT_DATA = "SELECT TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID , TRANS_AMOUNT,"
		+" TRANS_DATE, TRANS_STATUS, REASON_ID,CREATED_BY, TRANS_KEY_VALUE,PARENT_NAME1,PARENT_NAME2,PARENT_NAME3,PARENT_NAME4,ACCOUNT_ID,COUNT(TRANS_ID)over() RECORD_COUNT ";
		

	protected final static String SQL_TRANSACTION_REPORT_DATA_TRANS_ID_KEY = "SQL_TRANSACTION_REPORT_DATA_TRANS_ID";

	protected static final String SQL_TRANSACTION_REPORT_DATA_TRANS_ID= "SELECT	TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID ,"
		+" TRANS_AMOUNT, TRANS_DATE, TRANS_STATUS, REASON_ID, CREATED_BY, "
		+" TRANS_KEY_VALUE,REQ_CIRCLE_CODE,REC_CIRCLE_CODE,SERVICETAX,ESPCOMMISSION,"
		+" DEBITAMOUNT,CREDITEDAMOUNT,REQ_MOBILE_NUMBER,PARENT_NAME1,PARENT_NAME2,PARENT_NAME3,PARENT_NAME4,ACCOUNT_ID, COUNT(TRANS_ID)over() RECORD_COUNT " ;


	protected static final String SQL_TRANSACTION_REPORT_VIEW_DATA=	"SELECT	TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID , TRANS_AMOUNT,REQ_MOBILE_NUMBER,ACCOUNT_ID, "
		+"TRANS_DATE, TRANS_STATUS, REASON_ID, CREATED_BY, TRANS_KEY_VALUE ,ESPCOMMISSION,SERVICETAX, CREDITEDAMOUNT, DEBITAMOUNT, REQ_CIRCLE_CODE,REC_CIRCLE_CODE,PARENT_NAME1,PARENT_NAME2,PARENT_NAME3,PARENT_NAME4  ";
	
	protected final static String SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID_KEY ="SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID";
	protected static final String SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID = "FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ "AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = ? ";
			

	protected final static String SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID_KEY ="SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID";
	protected static final String SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID = "SELECT TRANS.TRANS_ID, TRANS.TRANS_TYPE, LOGIN.LOGIN_NAME, TRANS.TRANS_AMOUNT, TRANS.REQUESTER_ID, DETAILS.ACCOUNT_NAME, DETAILS.MOBILE_NUMBER, DETAILS.PARENT_ACCOUNT, DETAILS.CIRCLE_ID, TRANS.TRANS_DATE, TRANS.TRANS_STATUS, TRANS.REASON_ID, TDETAIL.DETAIL_MSG,TRANS.RECEIVER_ID, TRANS.TRANS_KEY_VALUE, TRANS.THIRD_PARTY "
			+ SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID;
	
	protected final static String SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_KEY ="SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE";
	protected static final String SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE = "FROM VR_TRANS_MASTER TRANS, VR_ACCOUNT_DETAILS DETAILS, VR_LOGIN_MASTER LOGIN, VR_TRANS_DETAIL TDETAIL WHERE TRANS.REQUESTER_ID = DETAILS.ACCOUNT_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID "
			+ "AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_TYPE != "
			+ RequestType.ACCOUNT.getValue();

	protected final static String SQL_SELECT_CUSTOMER_TRANSACTION_KEY ="SQL_SELECT_CUSTOMER_TRANSACTION";
	protected static final String SQL_SELECT_CUSTOMER_TRANSACTION = "SELECT DISTINCT TRANS.TRANS_ID, TRANS.TRANS_TYPE, LOGIN.LOGIN_NAME, TRANS.TRANS_AMOUNT, TRANS.REQUESTER_ID, DETAILS.ACCOUNT_NAME, DETAILS.MOBILE_NUMBER, DETAILS.PARENT_ACCOUNT, DETAILS.CIRCLE_ID, TRANS.TRANS_DATE, TRANS.TRANS_STATUS, TRANS.REASON_ID, TDETAIL.DETAIL_MSG,TRANS.RECEIVER_ID, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT1 "
			+ SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE;
	
	
	protected final static String SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL_KEY = "SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL";

	protected static final String SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL ="SELECT TRANS_ID, TRANS_TYPE, REQUESTER_ID, LOGIN_NAME TRANSFER_ACC_CODE , RECEIVER_ID ," 
		+" TRANS_AMOUNT, TRANS_DATE, TRANS_STATUS,REASON_ID, CREATED_BY, TRANS_KEY_VALUE,REQ_CIRCLE_CODE,REC_CIRCLE_CODE,REC_CIRCLE_ID, "
		+" SERVICETAX,ESPCOMMISSION,DEBITAMOUNT,CREDITEDAMOUNT,REQ_MOBILE_NUMBER,PARENT_NAME1,PARENT_NAME2,PARENT_NAME3,PARENT_NAME4,ACCOUNT_ID, COUNT(TRANS_ID)over() RECORD_COUNT"; 
	
	protected static final String SQL_CUST_TRANSACTION_REPORT_DATA_KEY ="SQL_CUST_TRANSACTION_REPORT_DATA";
	protected static final String SQL_CUST_TRANSACTION_REPORT_DATA =  " SELECT TRANS.THIRD_PARTY,TRANS.TRANS_ID,TRANS.TRANS_TYPE,LOGIN.LOGIN_NAME,TRANS.TRANS_AMOUNT,TRANS.REQUESTER_ID,ACC_DETAILS.ACCOUNT_NAME,ACC_DETAILS.MOBILE_NUMBER,ACC_DETAILS.PARENT_ACCOUNT,ACC_DETAILS.CIRCLE_ID,TRANS.TRANS_DATE,TRANS.TRANS_STATUS,TRANS.REASON_ID,TRANS.RECEIVER_ID, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT	 ";
	
	protected static final String SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT_KEY ="SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT";
	protected static final String SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT =  " SELECT TRANS.THIRD_PARTY,TRANS.TRANS_ID,TRANS.TRANS_TYPE,LOGIN.LOGIN_NAME,TRANS.TRANS_AMOUNT,TRANS.REQUESTER_ID,ACC_DETAILS.ACCOUNT_NAME,ACC_DETAILS.MOBILE_NUMBER,ACC_DETAILS.PARENT_ACCOUNT,ACC_DETAILS.CIRCLE_ID,TRANS.TRANS_DATE,TRANS.TRANS_STATUS,TRANS.REASON_ID,TRANS.RECEIVER_ID, COUNT(TRANS.TRANS_ID)over() RECORD_COUNT,TDETAIL.DETAIL_MSG	 ";
	
	protected static final String SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT_KEY = "SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT";
	protected static final String SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT =  " FROM VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS ACC_DETAILS,VR_LOGIN_MASTER LOGIN,VR_TRANS_DETAIL TDETAIL WHERE  TRANS.REQUESTER_ID = ACC_DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID AND TRANS.TRANS_ID = TDETAIL.TRANS_ID  ";
	
	protected static final String SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_KEY ="SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE ";
	protected static final String SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE =  " FROM VR_TRANS_MASTER TRANS,VR_ACCOUNT_DETAILS ACC_DETAILS,VR_LOGIN_MASTER LOGIN WHERE  TRANS.REQUESTER_ID = ACC_DETAILS.ACCOUNT_ID AND TRANS.REQUESTER_ID = LOGIN.LOGIN_ID  ";
	
	protected static final String SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS_KEY="SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS";
	protected static final String SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS="";
	/**
	 * Constructor to initialize connection
	 * 
	 * @param connection
	 */
	public ReportDaoRdbms(Connection connection) {
		super(connection);
		
		queryMap.put(SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE_KEY,SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE_KEY, SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE);
		queryMap.put(SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT_KEY, SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT);
		queryMap.put(SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT_KEY, SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT);
		queryMap.put(SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS_KEY, SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS);
		queryMap.put(SQL_CUST_TRANSACTION_REPORT_DATA_KEY, SQL_CUST_TRANSACTION_REPORT_DATA);
		queryMap.put(SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_KEY, SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE);
		
		queryMap.put(SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL_KEY, SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL);
		queryMap.put(SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID_KEY, SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID);
		queryMap.put(SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID_KEY, SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_WITH_ID);
		queryMap.put(SQL_TRANSACTION_REPORT_DATA_TRANS_ID_KEY,
				SQL_TRANSACTION_REPORT_DATA_TRANS_ID);	
		queryMap.put(SQL_CUST_TRAN_REPORT_DATA_KEY,SQL_CUST_TRAN_REPORT_DATA);	

		queryMap.put(SQL_TRANSACTION_REPORT_VIEW_DATA_KEY,
				SQL_TRANSACTION_REPORT_VIEW_DATA);
			

		queryMap.put(SQL_TRANSACTION_REPORT_DATA_KEY1,
				SQL_TRANSACTION_REPORT_DATA1);
		queryMap.put(SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA_KEY,
				SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA);
		
		queryMap.put(SQL_FETCH_TRAN_A2A_WHERE_CLAUSE_KEY,SQL_FETCH_TRAN_A2A_WHERE_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_SELECT_A2A_CLAUSE_KEY,SQL_FETCH_TRAN_SELECT_A2A_CLAUSE);
		
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY,SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE);
		queryMap.put(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY,SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE); 
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USRNAME_EXT_USERS_KEY, SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USRNAME_EXT_USERS);
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY,
				SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE);
		queryMap.put(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY,
				SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE);
		queryMap
				.put(
						SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY,
						SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS);
		queryMap.put(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY,
				SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS);
		queryMap.put(SQL_ACC2ACC_REPORT_WHERE_CLAUSE_KEY,
				SQL_ACC2ACC_REPORT_WHERE_CLAUSE);
		queryMap.put(SQL_ACC2ACC_REPORT_KEY, SQL_ACC2ACC_REPORT);
		queryMap.put(SQL_ACC2ACC_COUNT_KEY, SQL_ACC2ACC_COUNT);
		queryMap.put(SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE_KEY,
				SQL_TRANSFER_SUMMARY_REPORT_WHERE_CLAUSE);
		queryMap.put(SQL_TRANSFER_SUMMARY_REPORT_KEY,
				SQL_TRANSFER_SUMMARY_REPORT);
		queryMap
				.put(SQL_TRANSFER_SUMMARY_COUNT_KEY, SQL_TRANSFER_SUMMARY_COUNT);
		queryMap.put(SQL_TRANSFER_SUMMARY_CHILD_COUNT_KEY,
				SQL_TRANSFER_SUMMARY_CHILD_COUNT);
		queryMap.put(SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE_KEY,
				SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE);
		queryMap.put(SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_KEY,
				SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT);
		queryMap.put(SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE_KEY,
				SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE);
		queryMap.put(SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE_KEY,
				SQL_TRANSACTION_REPORT_DATA_WHERE_CLAUSE);
		queryMap.put(SQL_TRANSACTION_REPORT_COUNT_KEY,
				SQL_TRANSACTION_REPORT_COUNT);
		queryMap.put(SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE_KEY,
				SQL_TRANSACTION_REPORT_CHILD_WHERE_CLAUSE);
		queryMap.put(SQL_TRANSACTION_REPORT_CHILD_COUNT_KEY,
				SQL_TRANSACTION_REPORT_CHILD_COUNT);
		queryMap.put(SQL_TRANSACTION_REPORT_DATA_KEY,
				SQL_TRANSACTION_REPORT_DATA);
		queryMap.put(SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE_KEY,
				SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_WHERE_CLAUSE);
		queryMap.put(SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_KEY,
				SQL_ALL_CHILD_TRANSACTION_REPORT_DATA);
		queryMap.put(SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_KEY,
				SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT);
		queryMap.put(SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_RECHARGE_KEY,
				SQL_TRANSACTION_SUM_RECHARGE_DATA_COUNT_RECHARGE);
		queryMap.put(SQL_TRANSACTION_SUM_RECHARGE_DATA_KEY,
				SQL_TRANSACTION_SUM_RECHARGE_DATA);
		queryMap.put(SQL_TRANSACTION_SUM_RECHARGE_DATA_RECHARGE_KEY,
				SQL_TRANSACTION_SUM_RECHARGE_DATA_RECHARGE);
		queryMap.put(SQL_GENERAL_SELECT_START_CLAUSE_KEY,
				SQL_GENERAL_SELECT_START_CLAUSE);
		queryMap.put(SQL_GENERAL_SELECT_END_CLAUSE_KEY,
				SQL_GENERAL_SELECT_END_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_SELECT_CLAUSE_KEY,
				SQL_FETCH_TRAN_SELECT_CLAUSE);
		queryMap.put(SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE_KEY,
				SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE);
		queryMap.put(SQL_FETCH_ESP_SELECT_CLAUSE_KEY,
				SQL_FETCH_ESP_SELECT_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_KEY,
				SQL_FETCH_TRAN_WHERE_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY,
				SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER);
		queryMap.put(SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY,
				SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER);
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A_KEY,
				SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A);
		queryMap.put(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY,
				SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY,
				SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE);
		queryMap.put(SQL_FETCH_TRAN_FROM_QUERY_CLAUSE_KEY,
				SQL_FETCH_TRAN_FROM_QUERY_CLAUSE);
		
		queryMap.put(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER_KEY,
				SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER);
		queryMap.put(SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER_KEY,
				SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER);
		queryMap.put(SQL_SELECT_CUSTOMER_TRANSACTION_KEY,SQL_SELECT_CUSTOMER_TRANSACTION);
		queryMap.put(SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE_KEY,SQL_SELECT_CUSTOMER_TRANSACTION_WHERE_CLAUSE);
		
		queryMap.put(SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_KEY,SQL_FETCH_CUST_TRAN_WHERE_CLAUSE);
		
		
	}

	

	/**
	 * This method will be used provide a list of account to account
	 * transactions for external user logged in.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * @param lowerBound -
	 *            specifies the number from which to fetch the records
	 * @param upperBound -
	 *            specifies the number up to which to fetch the records
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getTransactionRptA2AChildList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {
		logger.info("Inside getTransactionRptA2AChildList()...");

		/** get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		long parentId = mtDTO.getParentId();
		String status = mtDTO.getStatus();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		Account2AccountReport accountReport = null;
		ArrayList<Account2AccountReport> acc2accList = new ArrayList<Account2AccountReport>();

		try {
			StringBuilder sql = new StringBuilder();
			StringBuilder query = new StringBuilder();
			int paramCount = 1;
			/**
			 * if status is null then fetch all successful as well as failure
			 * transactions else fetch the transactions based on the status
			 */
			sql.append(queryMap.get(SQL_ACC2ACC_REPORT_KEY));
			if (!"-1".equals(status)) {
				sql.append(" AND TRANS.TRANS_STATUS = ?");
			}
			sql.append(" AND TRANS_TYPE = ");
			sql.append(RequestType.ACCOUNT.getValue());

			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {

					/** search according to parent account */
					sql
							.append(" AND DETAILS1.PARENT_ACCOUNT = LOGIN.LOGIN_ID AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");
				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/** search according to account code */
					sql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");
				}
				sql
						.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ORDER BY TRANS.TRANS_ID DESC ");
				/** apply the pagination query */
				query.append("SELECT * from(select a.*,ROWNUM rnum FROM (");
				query.append(sql);
				query.append(") a Where ROWNUM<=?)Where rnum>=?");
				ps = connection.prepareStatement(query.toString());

				/** set the values in the statement */
				ps.setString(paramCount++, status);
				if (startDt != null && !startDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				}
				if (endDt != null && !endDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				}
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
				ps.setLong(paramCount++, parentId);
				ps.setString(paramCount++, String.valueOf(upperBound));
				ps.setString(paramCount++, String.valueOf(lowerBound + 1));
			}
			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				accountReport = new Account2AccountReport();
				accountReport.setReceivingAccountCode(rs
						.getString("RECEIVER_ACC_CODE"));
				accountReport
						.setTransactionAmount(rs.getDouble("TRANS_AMOUNT"));
				accountReport.setTransactionId(rs.getLong("TRANS_ID"));
				accountReport.setStatus(rs.getString("TRANS_STATUS"));
				accountReport.setTransferringAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));
				accountReport.setTransactionDate(rs
						.getTimestamp("CREATED_DATE"));
				accountReport.setCreatedBy(rs.getString("TRANSFER_ACC_CODE"));
				accountReport.setReason(rs.getString("REASON_ID"));
				accountReport.setRowNum(rs.getString("RNUM"));
				accountReport.setTotalRecords(rs.getInt("RECORD_COUNT"));
				/** add each record to the list */
				acc2accList.add(accountReport);
			}

		} catch (SQLException e) {
			logger
					.error(
							"Exception occured while reteriving Account2Account list for external user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/** Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);
		}
		logger.info("Executed getTransactionRptA2AChildList()...");
		/** return the list */
		return acc2accList;
	}

	
	
	
	
	/**
	 * This method will be used provide a list of account to account
	 * transactions for internal user logged in.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * @param lowerBound -
	 *            specifies the number from which to fetch the records.
	 * @param upperBound -
	 *            specifies the number up to which to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */

	/*public ArrayList getTransactionRptA2AList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {
		logger.info("Inside getTransactionRptA2AList()...");

		*//** get the data from the input DTO *//*
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String status = mtDTO.getStatus();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		Account2AccountReport accountReport = null;
		ArrayList<Account2AccountReport> acc2accList = new ArrayList<Account2AccountReport>();

		try {
			StringBuilder sql = new StringBuilder();
			StringBuilder query = new StringBuilder();
			int paramCount = 1;
			*//**
			 * if status is null then fetch all successful as well as failure
			 * transactions else fetch the transactions based on the status.
			 *//*
			sql.append(queryMap.get(SQL_ACC2ACC_REPORT_KEY));
			if (!"-1".equals(status)) {
				sql.append(" AND TRANS.TRANS_STATUS = ?");
			}
			if (0 != circleId) {
				*//** if circle user, show records of respective circle *//*
				sql.append(" AND DETAILS.CIRCLE_ID = ");
				sql.append(circleId);
			}
			sql.append(" AND TRANS_TYPE = ");
			sql.append(RequestType.ACCOUNT.getValue());

			if (startDt != null && !startDt.equals("")) {
				*//** search according to Start Date *//*
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				*//** search according to End date *//*
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					*//** search according to parent account *//*
					sql
							.append(" AND DETAILS1.PARENT_ACCOUNT = LOGIN.LOGIN_ID AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");
				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					*//** search according to account code *//*
					sql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");
				}
				sql.append(" ORDER BY TRANS.TRANS_ID DESC");
				*//** apply the pagination query *//*
				query.append("SELECT * from(select a.*,ROWNUM rnum FROM (");
				query.append(sql);
				query.append(") a Where ROWNUM<=?)Where rnum>=?");
				ps = connection.prepareStatement(query.toString());

				*//** set the values in the statement *//*
				if (!"-1".equals(status)) {
					ps.setString(paramCount++, status);
				}
				if (startDt != null && !startDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				}
				if (endDt != null && !endDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				}
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
				ps.setString(paramCount++, String.valueOf(upperBound));
				ps.setString(paramCount++, String.valueOf(lowerBound + 1));
			}
			*//** execute the query *//*
			rs = ps.executeQuery();

			*//** iterate the resultset *//*
			while (rs.next()) {
				accountReport = new Account2AccountReport();
				accountReport.setReceivingAccountCode(rs
						.getString("RECEIVER_ACC_CODE"));
				accountReport
						.setTransactionAmount(rs.getDouble("TRANS_AMOUNT"));
				accountReport.setTransactionId(rs.getLong("TRANS_ID"));
				accountReport.setStatus(rs.getString("TRANS_STATUS"));
				accountReport.setTransferringAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));
				accountReport.setTransactionDate(rs
						.getTimestamp("CREATED_DATE"));
				accountReport.setCreatedBy(rs.getString("TRANSFER_ACC_CODE"));
				accountReport.setReason(rs.getString("REASON_ID"));
				accountReport.setRowNum(rs.getString("RNUM"));
				accountReport.setTotalRecords(rs.getInt("RECORD_COUNT"));

				*//** add each record to the list *//*
				acc2accList.add(accountReport);
			}

		} catch (SQLException e) {
			logger
					.error(
							"Exception occured while reteriving Account2Account List for internal user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			*//** Close the statement,resultset *//*
			DBConnectionManager.releaseResources(ps, rs);
		}
		logger.info("Executed getTransactionRptA2AList()...");
		*//** return the list *//*
		return acc2accList;
	}*/

	/*
	 * (non-Javadoc)
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionRptA2AList1(com.ibm.virtualization.recharge.dto.ReportInputs, int, int, boolean)
	 */
	
	public ArrayList getTransactionRptA2AList(ReportInputs mtDTO,
			int lowerBound, int upperBound,boolean isExport) throws DAOException {
		logger.info("Inside getTransactionRptA2AList()...");

		/** get the data from the input  DTO */
		PreparedStatement ps = null;
		ResultSet rs = null;
		Account2AccountReport accountReport = null;
		ArrayList<Account2AccountReport> acc2accList = new ArrayList<Account2AccountReport>();

		try {
			List<Object> params = new ArrayList<Object>();
			
			/**
			 * if status is null then fetch all successful as well as failure
			 * transactions else fetch the transactions based on the status.
			 */

			StringBuilder sql = buildA2ATransactionQuery(mtDTO, params,isExport,upperBound,lowerBound);	
			/** execute the query */
			rs = execute(sql.toString(), params);
			/** iterate the resultset */
			while (rs.next()) {
				accountReport = new Account2AccountReport();
				accountReport.setReceivingAccountCode(rs
						.getString("RECEIVER_ACC_CODE"));
				accountReport
						.setTransactionAmount(rs.getDouble("TRANS_AMOUNT"));
				accountReport.setTransactionId(rs.getLong("TRANS_ID"));
				accountReport.setStatus(rs.getString("TRANS_STATUS"));
				accountReport.setTransferringAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));
				accountReport.setTransactionDate(rs
						.getTimestamp("CREATED_DATE"));
				accountReport.setCreatedBy(rs.getString("TRANSFER_ACC_CODE"));
				accountReport.setReason(rs.getString("REASON_ID"));
				/*Fetch transaction data to be exported to excel */
				if(isExport){
					double debitAmount = rs.getDouble("DEBIT_AMOUNT");

					logger.info("debitAmount : " + debitAmount);
					accountReport.setDebitAmount(debitAmount);
					
					// to find the Source Operating Balance before recharge
					double availbalAfterRecharge = rs.getDouble("BALANCE_AFTER_RECHARGE");
					logger.info("SourcebalanceAfterRecharge is :"
							+ availbalAfterRecharge);
					accountReport
							.setSourceAvailBalAfterRecharge(availbalAfterRecharge);

					if (TransactionStatus.SUCCESS.getValue() == rs
							.getInt("TRANS_STATUS")) {
						// to find the Source Operating Balance After recharge
						// TODO : Mar 07,2008, This comparision
						// (availbalAfterRecharge > 0.0) needs to be removed
						// once the record from the Trans_Master & detail table
						// are removed
						double availbalBeforeRecharge = 0.0;
						if (availbalAfterRecharge > 0.0){
						 availbalBeforeRecharge = availbalAfterRecharge
								+ debitAmount;
						logger.info("SourcebalanceBeforeRecharge : "
								+ availbalBeforeRecharge);
						}else{
							accountReport
							.setSourceAvailBalBeforeRecharge(availbalAfterRecharge);
						}
						accountReport
								.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
					} else {
						double availbalBeforeRecharge = availbalAfterRecharge;
						accountReport
								.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
					}
					
				}
				// for pagination 
				if(isExport==false){ 
					accountReport.setRowNum(rs.getString("RNUM"));
					accountReport.setTotalRecords(rs.getInt("RECORD_COUNT"));
				}

				/** add each record to the list */
				acc2accList.add(accountReport);
			}

		}catch (SQLException e) {
			logger
					.error(
							"Exception occured while reteriving Account2Account List for internal user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/** Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);
		}
		logger.info("Executed getTransactionRptA2AList()...");
		/** return the list */
		return acc2accList;
	}
	
	

	
	
	/**
	 * This method will be used provide a list of all account to account
	 * transfer summary for external user logged in. This will provide all the
	 * records and is independent of pagination logic.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getTransferSummaryRptA2AChildListAll(
			ReportInputs mtDTO) throws DAOException {
		logger.info("Inside getTransferSummaryRptA2AChildListAll()...");

		/** get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		long parentId = mtDTO.getParentId();
		String status = mtDTO.getStatus();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		PreparedStatement pstmt = null;
		PreparedStatement pstmtTotalTran = null;
		ResultSet rs = null;
		Account2AccountTransferReport acc2accTransferReport = null;
		ArrayList<Account2AccountTransferReport> acc2accList = new ArrayList<Account2AccountTransferReport>();

		try {
			StringBuilder sql = new StringBuilder();
			int paramCount = 1;
			double espCommission = 0.0;

			/**
			 * if status is null then fetch all successful as well as failure
			 * transactions else fetch the transactions based on the status.
			 */
			sql.append(queryMap.get(SQL_TRANSFER_SUMMARY_COUNT_KEY));
			if (!"-1".equals(status)) {
				sql.append(" AND TRANS.TRANS_STATUS = ?");
			}
			sql.append(" AND TRANS_TYPE = ");
			sql.append(RequestType.ACCOUNT.getValue());

			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/** search according to parent account */
					sql
							.append(" AND DETAILS1.PARENT_ACCOUNT = LOGIN.LOGIN_ID AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");
				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/** search according to account code */
					sql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");
				}
				sql
						.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ");
				ps = connection.prepareStatement(sql.toString());

				/** set the values in the statement */
				if (!"-1".equals(status)) {
					ps.setString(paramCount++, status);
				}
				if (startDt != null && !startDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				}
				if (endDt != null && !endDt.equals("")) {
					ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				}
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
				ps.setLong(paramCount++, parentId);
			}
			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				if (rs.getLong("TOTAL_TRANSCTIONS") == 0) {
					logger.error("No records found for the search criteria");
					throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
				}
				acc2accTransferReport = new Account2AccountTransferReport();
				/** if status is successful */
				if ("0".equals(status)) {
					acc2accTransferReport.setNoSuccessfulTransaction(rs
							.getLong("TOTAL_TRANSCTIONS"));
					acc2accTransferReport.setValueSuccessfulTransaction(rs
							.getDouble("TRANSACTION_AMT"));
					acc2accTransferReport.setTotalTransaction(rs
							.getLong("TOTAL_TRANSCTIONS"));
				} else if ("1".equals(status)) {
					/** if status is failure */
					acc2accTransferReport.setNoFailedTransaction(rs
							.getLong("TOTAL_TRANSCTIONS"));
					acc2accTransferReport.setValueFailedTransaction(rs
							.getDouble("TRANSACTION_AMT"));
					acc2accTransferReport.setTotalTransaction(rs
							.getLong("TOTAL_TRANSCTIONS"));
				} else if ("-1".equals(status)) {
					/** if status is to show all transactions */
					acc2accTransferReport.setValueSuccessfulTransaction(rs
							.getDouble("TRANSACTION_AMT"));
					acc2accTransferReport.setTotalTransaction(rs
							.getLong("TOTAL_TRANSCTIONS"));
				}
			}

			/**
			 * This query will fetch the msg details information for each
			 * transaction
			 */
			StringBuilder msgDetailsQuery = new StringBuilder();
			int msgParamCount = 1;
			/**
			 * if status is null then fetch all successful as well as failure
			 * transactions else fetch the transactions based on the status.
			 */
			msgDetailsQuery.append(queryMap
					.get(SQL_TRANSFER_SUMMARY_REPORT_KEY));
			if (!"-1".equals(status)) {
				msgDetailsQuery.append(" AND TRANS.TRANS_STATUS = ?");
			}
			msgDetailsQuery.append(" AND TRANS_TYPE = ");
			msgDetailsQuery.append(RequestType.ACCOUNT.getValue());

			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				msgDetailsQuery.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				msgDetailsQuery.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}
			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/** search according to parent account */
					msgDetailsQuery
							.append(" AND DETAILS1.PARENT_ACCOUNT IN(SELECT LOGIN_ID FROM VR_LOGIN_MASTER WHERE UPPER(LOGIN_NAME) LIKE ?)");
				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/** search according to account code */
					msgDetailsQuery
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");
				}
				msgDetailsQuery
						.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ORDER BY TRANS.TRANS_ID DESC ");
				pstmt = connection.prepareStatement(msgDetailsQuery.toString());

				/** set the values in the statement */
				if (!"-1".equals(status)) {
					pstmt.setString(msgParamCount++, status);
				}
				if (startDt != null && !startDt.equals("")) {
					pstmt.setDate(msgParamCount++, Utility.getSqlDate(startDt));
				}
				if (endDt != null && !endDt.equals("")) {
					pstmt.setDate(msgParamCount++, Utility.getSqlDate(endDt));
				}
				pstmt.setString(msgParamCount++, searchValue.toUpperCase()
						+ "%");
				pstmt.setLong(msgParamCount++, parentId);
			}
			/** execute the query */
			rs = pstmt.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				String message = rs.getString("DETAIL_MSG");
				
				espCommission = espCommission
						+ Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("Esp Commission : " + espCommission);

			}
			acc2accTransferReport.setTotalEspCommission(espCommission);
			acc2accTransferReport.setTransactionType(RequestType.ACCOUNT
					.toString());

			/**
			 * This query is used to fetch the total number of transactions
			 * count performed by the user
			 */
			StringBuilder totalTransactionsQuery = new StringBuilder();
			int totalTranCount = 1;

			totalTransactionsQuery.append(queryMap
					.get(SQL_TRANSFER_SUMMARY_COUNT_KEY));
			totalTransactionsQuery.append(" AND TRANS_TYPE = ");
			totalTransactionsQuery.append(RequestType.ACCOUNT.getValue());

			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				totalTransactionsQuery
						.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				totalTransactionsQuery
						.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}
			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/** search according to parent account */
					totalTransactionsQuery
							.append(" AND DETAILS1.PARENT_ACCOUNT IN(SELECT LOGIN_ID FROM VR_LOGIN_MASTER WHERE UPPER(LOGIN_NAME) LIKE ?)");

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/** search according to account code */
					totalTransactionsQuery
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");
				}
				totalTransactionsQuery
						.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ");

				pstmtTotalTran = connection
						.prepareStatement(totalTransactionsQuery.toString());

				/** set the values in the statement */
				if (startDt != null && !startDt.equals("")) {
					pstmtTotalTran.setDate(totalTranCount++, Utility
							.getSqlDate(startDt));
				}
				if (endDt != null && !endDt.equals("")) {
					pstmtTotalTran.setDate(totalTranCount++, Utility
							.getSqlDate(endDt));
				}
				pstmtTotalTran.setString(totalTranCount++, searchValue
						.toUpperCase()
						+ "%");
				pstmtTotalTran.setLong(totalTranCount++, parentId);
			}
			/** execute the query */
			rs = pstmtTotalTran.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				acc2accTransferReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
			}

			/** add each record to the list */
			acc2accList.add(acc2accTransferReport);
		} catch (SQLException e) {
			logger
					.error(
							"Exception occured while reteriving all account to account transfer summary for external user logged in"
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/** Close the statement,resultset for success or failure transactions */
			DBConnectionManager.releaseResources(ps, rs);
			/** Close the statement,resultset for msg detail query */
			DBConnectionManager.releaseResources(pstmt, rs);
			/** Close the statement,resultset for total transations */
			DBConnectionManager.releaseResources(pstmtTotalTran, rs);
		}
		logger.info("Executed getTransferSummaryRptA2AChildListAll()...");
		/** return the list */
		return acc2accList;
	}

	/**
	 * This method will be used provide a list of all account to account
	 * transfer summary for internal user logged in. This will provide all the
	 * records and is independent of pagination logic.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getTransferSummaryRptA2AListAll(ReportInputs mtDTO)
			throws DAOException {

		logger.info("Inside getTransferSummaryRptA2AListAll()..." + mtDTO);
		ResultSet rs = null;
		Account2AccountTransferReport transactionSumReport = null;
		ArrayList<Account2AccountTransferReport> transactionSumReportList = new ArrayList<Account2AccountTransferReport>();
		try {
			List<Object> params = new ArrayList<Object>();
			//double espCommission = 0;

			// start of successful transaction
			StringBuilder sql = buildTransactionA2ASummaryQuery(mtDTO, params,
					TransactionStatus.SUCCESS);
			rs = execute(sql.toString(), params);
			long totalTransactions = 0;
			if (rs.next()) {
				transactionSumReport = new Account2AccountTransferReport();
				totalTransactions = rs.getLong("TOTAL_TRANSCTIONS");
				transactionSumReport.setNoSuccessfulTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				transactionSumReport.setValueSuccessfulTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				transactionSumReport.setTransactionType(mtDTO.getRequestType()
						.name());
				//transactionSumReport.setTotalEspCommission(espCommission);
			}
			// end of successful transaction

			// start of failed transaction
			params = new ArrayList<Object>();
			sql = buildTransactionA2ASummaryQuery(mtDTO, params,
					TransactionStatus.FAILURE);
			rs = execute(sql.toString(), params);
			if (rs.next()) {
				totalTransactions += rs.getLong("TOTAL_TRANSCTIONS");
				transactionSumReport.setNoFailedTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				transactionSumReport.setValueFailedTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				transactionSumReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				transactionSumReport.setTransactionType(mtDTO.getRequestType()
						.name());
			}
			transactionSumReport.setTotalTransaction(totalTransactions);
			// end of failed transaction

//			// Get the ESP Commission
//			params = new ArrayList<Object>();
//			sql = buildTransactionA2ASummaryQuery(mtDTO, params,
//					TransactionStatus.FAILURE, true);
//
//			rs = execute(sql.toString(), params);
//			while (rs.next()) {
//				espCommission = espCommission
//						+ Utility.parseMessage(rs.getString("DETAIL_MSG"),
//								"espCommission");
//				logger.info("Esp Commission : " + espCommission);
//			}
//
//			transactionSumReport.setTotalEspCommission(espCommission);
			if (totalTransactions != 0) {
				transactionSumReportList.add(transactionSumReport);
			}

		} catch (SQLException e) {
			e.printStackTrace();
			logger.error("Exception occured while reteriving.Account List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset for success or failure transactions */
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException sqlException) {
				logger.error(
						"  Could Not Close ResultSet and Statement. Reason:"
								+ sqlException.getMessage() + ". Error Code:"
								+ sqlException.getErrorCode(), sqlException);
			}
		}
		logger.info("Executed getTransferSummaryRptA2AListAll ...");
		return transactionSumReportList;

	}

	
	// *********** Implementation for Transaction Report Starts *********

	

	
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionRptList(com.ibm.virtualization.recharge.dto.ReportInputs,
	 *      int, int)
	 */
	public ArrayList getTransactionRptList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {
		logger.info("Inside getTransactionRptList()...");

		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String status = mtDTO.getStatus();
		RequestType requestType = mtDTO.getRequestType();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			StringBuilder strSql = new StringBuilder();
			StringBuilder strQuery = new StringBuilder();
			int paramCount = 1;
			strSql.append(queryMap.get(SQL_TRANSACTION_REPORT_DATA_KEY));
			if (0 != circleId) {
				// if circle user, show records of respective circle
				strSql.append(" AND DETAILS.CIRCLE_ID = ");
				strSql.append(circleId);
			}

			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType()
					.getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}// else if Request Type is VAS

			// , append TransactionState accordingly
			strSql.append(" OR TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			strSql.append(" AND TRANS.TRANS_TYPE = ? ");
			strSql.append(" AND TRANS.TRANS_STATUS = ? ");
			strSql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			strSql.append("AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			/*
			 * if(requestType.getValue()!=RequestType.RECHARGE.getValue()){
			 * strSql.append(" AND TRANS.RECEIVER_ID = DETAILS1.MOBILE_NUMBER
			 * "); }else{ strSql.append(" AND TRANS.RECEIVER_ID =
			 * DETAILS1.ACCOUNT_ID "); }
			 */
			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					strSql
							.append(" AND DETAILS.PARENT_ACCOUNT = LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

					strQuery
							.append("SELECT * from(select a.*,ROWNUM rnum FROM (");
					strQuery.append(strSql.toString());
					strQuery.append(" ORDER BY TRANS.TRANS_ID DESC  ) a "
							+ " Where ROWNUM<=?) Where rnum>=? ");
					// SQL Query
					logger
							.info(" Query for getTransactionRptList for Parent Code "
									+ strQuery.toString());

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					strSql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");

					strQuery
							.append(" SELECT * from(select a.*,ROWNUM rnum FROM (");
					strQuery.append(strSql.toString());

					strQuery.append(" ORDER BY TRANS.TRANS_ID DESC ) a ")
							.append(" Where ROWNUM<=?)Where rnum>=? ");
					// SQL Query
					logger
							.info(" Query for getTransactionRptList for Account Code "
									+ strQuery.toString());
				}
				ps = connection.prepareStatement(strQuery.toString());
				ps.setInt(paramCount++, requestType.getValue());
				ps.setInt(paramCount++, Integer.parseInt(status));
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
				ps.setString(paramCount++, String.valueOf(upperBound));
				ps.setString(paramCount++, String.valueOf(lowerBound + 1));
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				transactionReport = new TransactionReport();

				// new change group name added
				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("REQUESTER_ID"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));

				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				// till the time message is parsed using the parseMessage method
				transactionReport.setCommission(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "espCommission"));
				transactionReport.setProcessingFee(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "processingFee"));
				transactionReport.setServiceTax(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "serviceTax"));
				transactionReport.setTalkTime(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "CreditedAmount"));
				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
				transactionReport.setRowNum(rs.getString("RNUM"));
				transactionReport.setTotalRecords(rs.getInt("RECORD_COUNT"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
		        logger.debug("Validity : " + validity);
		        transactionReport.setValidity(validity);
				transactionList.add(transactionReport);
			}

		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("ReportDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}catch (SQLException e) {
			logger.error("Exception occured while reteriving List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);

		}
		logger.info("Executed getTransactionRptList()...");
		return transactionList;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionRptChildList(com.ibm.virtualization.recharge.dto.ReportInputs,
	 *      int, int)
	 */
	public ArrayList getTransactionRptChildList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {
		logger.info(" Started... getTransactionRptChildList()..");

		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		long parentId = mtDTO.getParentId();
		String status = mtDTO.getStatus();
		RequestType requestType = mtDTO.getRequestType();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			StringBuilder strSql = new StringBuilder();
			StringBuilder strQuery = new StringBuilder();

			int paramCount = 1;
			strSql.append(queryMap
					.get(SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_KEY));
			//	
			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}// else if Request Type is VAS

			// , append TransactionState accordingly
			strSql.append(" OR TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			if (0 != parentId) {
				strSql
						.append(" AND TRANS.TRANS_STATUS = ? AND TRANS.TRANS_TYPE = ? ");
				strSql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
				strSql.append("AND TRUNC(TRANS.CREATED_DATE) <= ? ");
			}

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					strSql
							.append(" AND DETAILS.PARENT_ACCOUNT = LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

					strQuery
							.append("SELECT * from(select a.*,ROWNUM rnum FROM (");
					strQuery.append(strSql.toString());
					strQuery.append(" ORDER BY TRANS.TRANS_ID DESC ) a ")
							.append("Where ROWNUM<=?)Where rnum>=?");
					// SQL Query
					logger
							.info(" Query for getTransactionRptChildList for Parent Code "
									+ strQuery.toString());
				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					strSql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ");

					strQuery
							.append("SELECT * from(select a.*,ROWNUM rnum FROM (");
					strQuery.append(strSql.toString());
					strQuery.append(" ORDER BY TRANS.TRANS_ID DESC ) a ")
							.append("Where ROWNUM<=?)Where rnum>=?");
					// SQL Query
					logger
							.info(" Query for getTransactionRptChildList for Account Code "
									+ strQuery.toString());
				}
				ps = connection.prepareStatement(strQuery.toString());
				ps.setLong(paramCount++, parentId);
				ps.setInt(paramCount++, Integer.parseInt(status));
				ps.setInt(paramCount++, requestType.getValue());
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
				ps.setString(paramCount++, String.valueOf(upperBound));
				ps.setString(paramCount++, String.valueOf(lowerBound + 1));
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				transactionReport = new TransactionReport();
				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("TRANSFER_ACC_CODE"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));

				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				// till the time message is parsed using the parseMessage method
				transactionReport.setCommission(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "espCommission"));
				transactionReport.setProcessingFee(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "processingFee"));
				transactionReport.setServiceTax(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "serviceTax"));
				transactionReport.setTalkTime(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "CreditedAmount"));
				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
				// new change group name added
				transactionReport.setRowNum(rs.getString("RNUM"));
				transactionReport.setTotalRecords(rs.getInt("RECORD_COUNT"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
		        logger.debug("Validity : " + validity);
		        transactionReport.setValidity(validity);
				transactionList.add(transactionReport);
			}

		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("ReportDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}catch (SQLException e) {
			logger.error("Exception occured while reteriving.Account List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);

		}
		logger.info("Executed getTransactionRptChildList()...");
		return transactionList;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionRptListAll(com.ibm.virtualization.recharge.dto.ReportInputs)
	 */
	public ArrayList getTransactionRptListAll(ReportInputs mtDTO)
			throws DAOException {
		logger.info("Inside getTransactionRptListAll()...");
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String status = mtDTO.getStatus();
		RequestType requestType = mtDTO.getRequestType();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			StringBuilder strSql = new StringBuilder();
			int paramCount = 1;

			strSql.append(queryMap.get(SQL_TRANSACTION_REPORT_DATA_KEY));

			if (0 != circleId) {
				strSql.append(" AND DETAILS.CIRCLE_ID = ");
				strSql.append(circleId);
			}

			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());

			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}// else if Request Type is VAS, PostPaid

			// , append TransactionState accordingly
			strSql.append(" OR TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			strSql.append(" AND TRANS.TRANS_STATUS = ?");
			strSql.append(" AND TRANS.TRANS_TYPE = ?");
			strSql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			strSql.append(" AND TRUNC(TRANS.CREATED_DATE) <= ?");

			if (searchType != null) {
				// search according to parent code
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					strSql
							.append(" AND DETAILS.PARENT_ACCOUNT = LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

					// SQL
					logger
							.info(" Query for getTransactionRptListAll for Parent Code "
									+ strSql.toString());

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					strSql
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ORDER BY TRANS_ID DESC ");
					logger
							.info(" Query for getTransactionRptListAll for Account Code "
									+ strSql.toString());
				}
				ps = connection.prepareStatement(strSql.toString());
				ps.setInt(paramCount++, Integer.parseInt(status));
				ps.setInt(paramCount++, requestType.getValue());
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				transactionReport = new TransactionReport();

				// new change group name added
				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("TRANSFER_ACC_CODE"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));
				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				// till the time message is parsed using the parseMessage method
				transactionReport.setCommission(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "espCommission"));
				transactionReport.setProcessingFee(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "processingFee"));
				transactionReport.setServiceTax(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "serviceTax"));
				transactionReport.setTalkTime(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "CreditedAmount"));
				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
		        logger.debug("Validity : " + validity);
		        transactionReport.setValidity(validity);
				transactionList.add(transactionReport);
			}

		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("ReportDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}catch (SQLException e) {
			logger.error(
					"Exception occured while reteriving All Transsaction List"
							+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);

		}
		logger.info("Executed getTransactionRptListAll ...");
		return transactionList;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionRptChildListAll(com.ibm.virtualization.recharge.dto.ReportInputs)
	 */
	public ArrayList getTransactionRptChildListAll(ReportInputs mtDTO)
			throws DAOException {
		logger.info("Inside getTransactionRptChildListAll()...");
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		long parentId = mtDTO.getParentId();
		int circleId = mtDTO.getCircleId();
		String status = mtDTO.getStatus();
		RequestType requestType = mtDTO.getRequestType();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			StringBuilder strSql = new StringBuilder();
			int paramCount = 1;

			strSql.append(queryMap
					.get(SQL_ALL_CHILD_TRANSACTION_REPORT_DATA_KEY));

			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				strSql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}// else if Request Type is VAS,

			strSql.append(" OR TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			if (0 != circleId) {
				// if circle user, show records of respective circle
				strSql.append(" AND DETAILS.CIRCLE_ID = ");
				strSql.append(circleId);
			}

			strSql.append(" AND LOGIN.STATUS = ? ");
			strSql.append(" AND TRANS.TRANS_TYPE = ? ");
			strSql.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? ");
			strSql.append(" AND TRUNC(TRANS.CREATED_DATE) <= ? ");

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					strSql
							.append(" AND DETAILS.PARENT_ACCOUNT=LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

					logger
							.info(" Query for getTransactionRptChildListAll for Parent Code "
									+ strSql.toString());

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					strSql
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ? ORDER BY TRANS_ID ");

					logger
							.info(" Query for getTransactionRptChildListAll for Account Code "
									+ strSql.toString());
				}
				ps = connection.prepareStatement(strSql.toString());
				ps.setLong(paramCount++, parentId);
				ps.setInt(paramCount++, Integer.parseInt(status));
				ps.setInt(paramCount++, requestType.getValue());
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				transactionReport = new TransactionReport();
				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("TRANSFER_ACC_CODE"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));

				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				// till the time message is parsed using the parseMessage method
				transactionReport.setCommission(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "espCommission"));
				transactionReport.setProcessingFee(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "processingFee"));
				transactionReport.setServiceTax(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "serviceTax"));
				transactionReport.setTalkTime(Utility.parseMessage(rs
						.getString("DETAIL_MSG"), "CreditedAmount"));

				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
		        logger.debug("Validity : " + validity);
		        transactionReport.setValidity(validity);
				transactionList.add(transactionReport);
			}

		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("ReportDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}catch (SQLException e) {
			logger.error("Exception occured while reteriving All Child List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset */
			DBConnectionManager.releaseResources(ps, rs);

		}
		logger.info("Executed getTransactionRptChildListAll()...");
		return transactionList;
	}

	
	/**
	 * This method executes the sql query passed as the parameter and returns
	 * the results as a Cached RowSet.
	 * 
	 * @param query -
	 *            The SQL Query
	 * @param params -
	 *            List of parameters
	 * 
	 * @return RowSet - Query result as a rowset object
	 * 
	 * @throws DBException -
	 *             if any error in executing the sql query
	 */
	private ResultSet execute(String query, List params) throws SQLException {
		// Create an ResultSet Object
		ResultSet rst = null;
		PreparedStatement pst = null;

		try {
			// Use PreparedStatement  object to execute the SQL Query
			pst = connection.prepareStatement(query);

			// Bind the columns values from the ArrayList object
			logger.info(query + "=" + params);
			if (params != null) {

 				for (int i = 0; i < params.size(); i++) {
					Object arg = params.get(i);
					int index = i + 1;
					if (arg instanceof String) {
						pst.setString(index, (String) arg);
					} else if (arg instanceof Integer) {
						pst.setInt(index, ((Integer) arg).intValue());
					} else if (arg instanceof Long) {
						pst.setLong(index, ((Long) arg).longValue());
					} else if (arg instanceof Boolean) {
						pst.setBoolean(index, ((Boolean) arg).booleanValue());
					} else if (arg instanceof Date) {
						pst.setDate(index, (java.sql.Date) arg);
					}
				}
			}
			
			rst = pst.executeQuery();
		}catch(SQLException e){
			e.printStackTrace();
			throw new SQLException(ExceptionCode.ERROR_DB_INTERNAL);
			
		} finally {
			/* Close the statement,resultset for success or failure transactions */
			// DBConnectionManager.releaseResources(pst, rst);
		}

		return rst;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionSummaryRptData(com.ibm.virtualization.recharge.dto.ReportInputs)
	 */
	
	public ArrayList getTransactionSummaryRptData(ReportInputs mtDTO)
			throws DAOException {

		logger.info("Started..." + mtDTO.toString());
		ResultSet rs = null;
		Account2AccountTransferReport transactionSumReport = null;
		ArrayList<Account2AccountTransferReport> transactionSumReportList = new ArrayList<Account2AccountTransferReport>();
		try {
			List<Object> params = new ArrayList<Object>();
		//	double espCommission = 0;

			// start of successful transaction
			StringBuilder sql = buildTransactionSummaryQuery(mtDTO, params,
					TransactionStatus.SUCCESS, false);
			rs = execute(sql.toString(), params);
			long totalTransactions = 0;
			if (rs.next()) {
				transactionSumReport = new Account2AccountTransferReport();
				totalTransactions = rs.getLong("TOTAL_TRANSCTIONS");
				transactionSumReport.setNoSuccessfulTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				if(!mtDTO.getRequestType().name().equalsIgnoreCase(RequestType.QUERY.name())){
				transactionSumReport.setValueSuccessfulTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				}
				transactionSumReport.setTransactionType(mtDTO.getRequestType()
						.name());
				//transactionSumReport.setTotalEspCommission(espCommission);
			}
			// end of successful transaction

			// start of failed transaction
			params = new ArrayList<Object>();
			sql = buildTransactionSummaryQuery(mtDTO, params,
					TransactionStatus.FAILURE, false);
			rs = execute(sql.toString(), params);
			if (rs.next()) {
				totalTransactions += rs.getLong("TOTAL_TRANSCTIONS");
				transactionSumReport.setNoFailedTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				if(!mtDTO.getRequestType().name().equalsIgnoreCase(RequestType.QUERY.name())){
				transactionSumReport.setValueFailedTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				}
				transactionSumReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				transactionSumReport.setTransactionType(mtDTO.getRequestType()
						.name());
			}
			transactionSumReport.setTotalTransaction(totalTransactions);
			// end of failed transaction

//			// Get the ESP Commission
//			params = new ArrayList<Object>();
//			sql = buildTransactionSummaryQuery(mtDTO, params,
//					TransactionStatus.FAILURE, true);
//
//			rs = execute(sql.toString(), params);
//			while (rs.next()) {
//				espCommission = espCommission + rs.getDouble("ESPCOMMISSION");
//				logger.info("Esp Commission : " + espCommission);
//			}
//			transactionSumReport.setTotalEspCommission(espCommission);
			
			if (totalTransactions != 0) {
				transactionSumReportList.add(transactionSumReport);
			}

		} catch (SQLException e) {
			e.printStackTrace();
			logger.error("Exception occured while reteriving.Account List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset for success or failure transactions */
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException sqlException) {
				logger.error(
						"  Could Not Close ResultSet and Statement. Reason:"
								+ sqlException.getMessage() + ". Error Code:"
								+ sqlException.getErrorCode(), sqlException);
			}
		}
		logger.info("Executed getTransferSummaryRptA2AListAll ...");
		return transactionSumReportList;
	}
	

	public ArrayList getTransactionRptList(ReportInputs mtDTO,
			int lowerBound, int upperBound, boolean isExport)
			throws DAOException {
		logger.info("Inside getTransactionRptList()...");
		logger.info("status="+mtDTO.getStatus());
		
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			
			List<Object> params = new ArrayList<Object>();
			StringBuilder strSql = new StringBuilder();
			strSql = buildTransactionReportQuery(mtDTO, params,lowerBound,upperBound,isExport);
			rs = execute(strSql.toString(), params);
			
			while (rs.next()) {
				transactionReport = new TransactionReport();

				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("REQUESTER_ID"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));

				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setParentName(rs.getString("PARENT_NAME1"));
				transactionReport.setParentName1(rs.getString("PARENT_NAME2"));
				transactionReport.setParentName2(rs.getString("PARENT_NAME3"));
				transactionReport.setParentName3(rs.getString("PARENT_NAME4"));
				transactionReport.setRequesterMobile(rs.getString("REQ_MOBILE_NUMBER"));
 				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				transactionReport.setReceiverAccountId(rs.getLong("ACCOUNT_ID"));

				
				/*Fetch transaction data to be exported to excel */
				if(isExport){

					transactionReport.setCommission(rs.getDouble("ESPCOMMISSION"));
					
					transactionReport.setServiceTax(rs.getDouble("SERVICETAX"));
					transactionReport.setTalkTime(rs.getDouble("CREDITEDAMOUNT"));
					
					// debitAmount
					double debitAmount = rs.getDouble("DEBITAMOUNT");
					// set the debit amount
					transactionReport.setDebitAmount(debitAmount);
					
					// subscriberCircleId
					transactionReport.setSubscriberCircleId(rs.getString("REC_CIRCLE_CODE"));
					
					// "requesterCircleId"
					transactionReport.setRequesterCircleId(rs.getString("REQ_CIRCLE_CODE"));
					
					/*If RequestType is RECHARGE, fetch balanceAfterRecharge,instatus,processing fee*/
					if(RequestType.RECHARGE.ordinal()==transactionReport.getTransactionType().ordinal()){
						double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_RECHARGE");
						
						logger.info("SourcebalanceAfterRecharge : "
								+ availbalAfterRecharge);
						transactionReport
								.setSourceAvailBalAfterRecharge(availbalAfterRecharge);

						double availbalBeforeRecharge = 0.0;
						if (TransactionStatus.SUCCESS.getValue() == rs
								.getInt("TRANS_STATUS")) {
							// to find the Source Operating Balance before
							// recharge
							availbalBeforeRecharge = availbalAfterRecharge
									+ debitAmount;
							
						} else {
							availbalBeforeRecharge = availbalAfterRecharge;
						}
						transactionReport
								.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
						logger.info("SourcebalanceBeforeRecharge : "
								+ availbalBeforeRecharge);
						transactionReport.setProcessingFee(rs.getDouble("PROCESSINGFEE"));
						transactionReport.setCardGroup(rs.getString("CARD_GROUP"));
					}	else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
							||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
							||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
						
						double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_TRANS");
						
						logger.info("SourcebalanceAfterRecharge : "+ availbalAfterRecharge);
						transactionReport.setSourceAvailBalAfterRecharge(availbalAfterRecharge);

						double availbalBeforeRecharge = 0.0;
						if (TransactionStatus.SUCCESS.getValue() == rs.getInt("TRANS_STATUS")) {
							// to find the Source Operating Balance before
							// recharge
							availbalBeforeRecharge = availbalAfterRecharge + debitAmount;
							
						} else {
							availbalBeforeRecharge = availbalAfterRecharge;
						}
						transactionReport.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
						logger.info("SourcebalanceBeforeRecharge : "+ availbalBeforeRecharge);
					}
				}
				
			
				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));			
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
				/*If RequestType is RECHARGE,fetch validity*/
				if(RequestType.RECHARGE.ordinal()==transactionReport.getTransactionType().ordinal()){
					transactionReport.setValidity(rs.getString("VALIDITY"));
					transactionReport.setInStatus(rs.getString("IN_STATUS"));
				}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
					transactionReport.setSelfcareStatus(rs.getString("SELFCARE_STATUS"));
				}
				if (!isExport) {
					transactionReport.setRowNum(rs.getString("RNUM"));
					transactionReport
							.setTotalRecords(rs.getInt("RECORD_COUNT"));
				}
				transactionList.add(transactionReport);
			}

		} 

		catch (SQLException e) {
			logger.error("Exception occured while reteriving List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			// Close the statement,resultset for success or failure transactions 
			try {
				if(rs != null){
					rs.close();
				}
			} catch (SQLException sqlException) {
				logger.error(
						"  Could Not Close ResultSet and Statement. Reason:"
								+ sqlException.getMessage() + ". Error Code:"
								+ sqlException.getErrorCode(), sqlException);
			}

		}
		logger.info("Executed getTransactionRptList()...");
		return transactionList;
	}

	/*
	 * (non-Javadoc)
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getRechargeTransactionRptList(com.ibm.virtualization.recharge.dto.ReportInputs, int, int, boolean)
	 */
	public ArrayList getRechargeTransactionRptList(ReportInputs mtDTO,
			int lowerBound, int upperBound, boolean isExport,String transId)
			throws DAOException {
	logger.debug("Inside getRechargeTransactionRptList()..");
		ResultSet rs = null;
		TransactionReport transactionReport = null;
		ArrayList<TransactionReport> transactionList = new ArrayList<TransactionReport>();

		try {
			
			List<Object> params = new ArrayList<Object>();
			StringBuilder strSql = new StringBuilder();
			
			strSql = buildRechargeTransactionReportQuery(mtDTO, params,lowerBound,upperBound,isExport,transId);
		
			rs = execute(strSql.toString(), params);
			
			while (rs.next()) {
				transactionReport = new TransactionReport();

				transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
				transactionReport.setTransactionType(TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE")));
				// transactionReport.setMtpAccountCode(rs.getString("REQUESTER_ID"));
				transactionReport.setMtpAccountCode(rs
						.getString("TRANSFER_ACC_CODE"));

				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				transactionReport.setReceiverAccountId(rs.getLong("ACCOUNT_ID"));
				
				
				/*Fetch transaction data to be exported to excel,details view page*/
				if(isExport ||(transId!=null)){
					
				
					transactionReport.setCommission(rs.getDouble("ESPCOMMISSION"));

					double debitAmount = rs.getDouble("DEBITAMOUNT");

					logger.info("debitAmount : " + debitAmount);
					transactionReport.setDebitAmount(debitAmount);
				
					String requesterMobile =rs.getString("REQ_MOBILE_NUMBER");
					logger.info("requesterMobile : " + requesterMobile);
					transactionReport.setRequesterMobile(requesterMobile);
					transactionReport.setServiceTax(rs.getDouble("SERVICETAX"));
					transactionReport.setTalkTime(rs.getDouble("CREDITEDAMOUNT"));
						
					transactionReport.setSubscriberCircleId(rs.getString("REC_CIRCLE_CODE"));
					transactionReport.setRequesterCircleId(rs.getString("REQ_CIRCLE_CODE"));
					

					if(RequestType.RECHARGE.ordinal()==transactionReport.getTransactionType().ordinal()){				
					// to find the Source Operating Balance before recharge
					double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_RECHARGE");
					logger.info("SourcebalanceAfterRecharge : "+ availbalAfterRecharge);
					transactionReport.setSourceAvailBalAfterRecharge(availbalAfterRecharge);
					double availbalBeforeRecharge = 0.0;
					if (TransactionStatus.SUCCESS.getValue() == rs.getInt("TRANS_STATUS")) {
						// to find the Source Operating Balance before
						// recharge
						availbalBeforeRecharge = availbalAfterRecharge+ debitAmount;
						
					} else {
						availbalBeforeRecharge = availbalAfterRecharge;
					}
					transactionReport.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
					logger.info("SourcebalanceBeforeRecharge : "+ availbalBeforeRecharge);
				
					transactionReport.setProcessingFee(rs.getDouble("PROCESSINGFEE"));
					//cardGroup
					transactionReport.setCardGroup(rs.getString("CARD_GROUP"));
				}
					else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
					
						double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_TRANS");
						logger.info("SourcebalanceAfterRecharge : "+ availbalAfterRecharge);
						transactionReport.setSourceAvailBalAfterRecharge(availbalAfterRecharge);
						double availbalBeforeRecharge = 0.0;
						if (TransactionStatus.SUCCESS.getValue() == rs.getInt("TRANS_STATUS")) {
							// to find the Source Operating Balance before
							// recharge
							availbalBeforeRecharge = availbalAfterRecharge+ debitAmount;
						
						} else {
							availbalBeforeRecharge = availbalAfterRecharge;
						}
						transactionReport.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
						logger.info("SourcebalanceBeforeRecharge : "+ availbalBeforeRecharge);
					
					}
				}	
				transactionReport.setTransactionDate(rs.getTimestamp("TRANS_DATE"));
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
				transactionReport.setParentName(rs.getString("PARENT_NAME1"));
				transactionReport.setParentName1(rs.getString("PARENT_NAME2"));
				transactionReport.setParentName2(rs.getString("PARENT_NAME3"));
				transactionReport.setParentName3(rs.getString("PARENT_NAME4"));
				if(RequestType.RECHARGE.ordinal()==transactionReport.getTransactionType().ordinal()){
				String validity =rs.getString("VALIDITY");
		        logger.debug("Validity : " + validity);
		        transactionReport.setValidity(validity);
		        transactionReport.setInStatus(rs.getString("IN_STATUS"));
				}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
					transactionReport.setSelfcareStatus(rs.getString("SELFCARE_STATUS"));
				}
				if (!isExport && (transId == null)) {
					transactionReport.setRowNum(rs.getString("RNUM"));
					transactionReport
							.setTotalRecords(rs.getInt("RECORD_COUNT"));
				}
				transactionList.add(transactionReport);
			}

		} catch (SQLException e) {
			logger.error("Exception occured while reteriving List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
	} finally {
			// Close the statement,resultset for success or failure transactions 
			try {
				if(rs != null){
					rs.close();
				}
			} catch (SQLException sqlException) {
				logger.error(
						"  Could Not Close ResultSet and Statement. Reason:"
								+ sqlException.getMessage() + ". Error Code:"
								+ sqlException.getErrorCode(), sqlException);
			}

		}
		logger.debug("Executed getTransactionRptList()...");
		return transactionList;
	}

	
	
	/*
	 * this function is used to  make a query for getting  transaction report data 
	 */
	private StringBuilder buildTransactionReportQuery(ReportInputs mtDTO,
			List<Object> params,int lowerBound, int upperBound,boolean isExport){
		// get the data from the input DTO 
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String status=mtDTO.getStatus();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();
		StringBuilder sql = new StringBuilder();
		if (!isExport){
			sql.append("SELECT * from(select a.*,ROW_NUMBER() over() rnum FROM (");
			sql.append(queryMap.get(SQL_TRANSACTION_REPORT_DATA_KEY1));
		}else{
			sql.append(queryMap.get(SQL_TRANSACTION_REPORT_EXPORTTOEXCEL_DATA_KEY));
		}	
		
		if(mtDTO.getRequestType()!= null){
			/*If RequestType is RECHARGE, fetch transaction data from Recharge Report table*/
			if((mtDTO.getRequestType().getValue())==RequestType.RECHARGE.ordinal()){
				if(isExport){
					sql.append(",BALANCE_AFTER_RECHARGE ");
					sql.append(",PROCESSINGFEE ");
					sql.append(",CARD_GROUP ");
				
				}
				sql.append(",VALIDITY ");
				sql.append(",IN_STATUS ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
			}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
				/*If RequestType is POSTPAID,fetch transaction data from Postpaid table*/
				sql.append(",SELFCARE_STATUS");	
				if(isExport){
					sql.append(",BALANCE_AFTER_TRANS ");
				}
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));
			}
		}

		/*Where clause for SQL Query*/
		sql.append(queryMap.get(SQL_FETCH_TRAN_WHERE_CLAUSE_KEY));
		
		params.add(Utility.getSqlDate(startDt));
		params.add(Utility.getSqlDate(endDt));
		
		
	/*If RequestType is POSTPAID,append TRANSACTION TYPE*/
		if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
				||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
				||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
			sql.append(" AND TRANS_TYPE = ?");
			params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
		}

//		/*If circle user or external user append circleid*/
// 		if (circleId != 0) {
//			sql.append(queryMap
//			.get(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY));
//			params.add(Integer.valueOf(circleId));
//		}
		
		/* Append Transaction status for successful,failed,duplicate or blackout transaction*/
 		if ((Integer.parseInt(status)) == TransactionStatus.SUCCESS.ordinal()) {
			sql.append(" AND TRANS_STATUS IN (?) ");
			params.add(Integer.valueOf(TransactionStatus.SUCCESS.ordinal()));
		} else if (Integer.parseInt(status)== TransactionStatus.FAILURE.ordinal()) {
			sql.append(" AND TRANS_STATUS IN (?, ?, ?) ");
			params.add(Integer.valueOf(TransactionStatus.FAILURE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.DUPLICATE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.BLACKOUT.ordinal()));
			
		/* Append Transaction status for pending transaction*/
		}else if (Integer.parseInt(status)== TransactionStatus.PENDING.ordinal())
		{
			sql.append(" AND TRANS_STATUS = ? ");
			params.add(Integer.valueOf(TransactionStatus.PENDING.ordinal()));
		}
		
		if (searchType != null) {
		if (searchType.trim().equalsIgnoreCase(
			Constants.SEARCH_TYPE_PARENT_CODE)) {
			/* search according to parent account*/ 
			if (Constants.USER_TYPE_EXTERNAL
				.equalsIgnoreCase(ctx.getType())) {
					sql.append(queryMap.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY));
					params.add(Long.valueOf(ctx.getId()));
					params.add(searchValue);
				} else {
					sql.append(queryMap.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY));
					params.add(searchValue);
				}
			
			} else if (searchType.trim().equalsIgnoreCase(
				Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
				/* search according to User Name*/ 
				if (circleId != 0 && Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					//sql.append(queryMap.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
					sql.append(queryMap.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
					params.add(Long.valueOf(ctx.getId()));
				}
				sql.append(queryMap.get(SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER_KEY));
				params.add(searchValue.toUpperCase() + "%");
				logger.info(" this is the SQL for Successfull transaction :---- "+ sql.toString());

			}
		}
		if (!isExport){
			/*add upper and lower bounds for pagination*/
			sql.append(") a)b Where rnum<=? AND rnum>=?");
			params.add(String.valueOf(upperBound));
			params.add(String.valueOf(lowerBound + 1));
		}
		
		return sql;


}
	
	/*
	 * this function is used to  make a query for getting  Circle Recharge Transaction report data 
	 */
	private StringBuilder buildRechargeTransactionReportQuery(
			ReportInputs mtDTO, List<Object> params, int lowerBound,
			int upperBound, boolean isExport, String transId) {
		// get the data from the input DTO 
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String status=mtDTO.getStatus();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();
		StringBuilder sql = new StringBuilder();
		
		if (transId != null) {
			/*Fetch Transaction data according to transId */
			sql.append(queryMap.get(SQL_TRANSACTION_REPORT_DATA_TRANS_ID_KEY));

			if((mtDTO.getRequestType().getValue())==RequestType.RECHARGE.ordinal()){
				sql.append(",VALIDITY");
				sql.append(",IN_STATUS ");
				sql.append(",PROCESSINGFEE ");
				sql.append(",BALANCE_AFTER_RECHARGE ");
				sql.append(",CARD_GROUP ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
				
			}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
				/*If RequestType is POSTPAID,fetch transaction data from Postpaid table*/
				sql.append(",SELFCARE_STATUS");	
				sql.append(",BALANCE_AFTER_TRANS ");
				 sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));	
			}
			sql.append(" TRANS_ID = ?");
			params.add(Integer.valueOf(transId));
		} else {
			if (isExport) {
				sql.append(queryMap.get(SQL_CUST_TRANSACTION_REPORT_DATA_EXPORTEXCEL_KEY));
				if((mtDTO.getRequestType().getValue())==RequestType.RECHARGE.ordinal()){
				sql.append(",VALIDITY");
				sql.append(",IN_STATUS ");
				sql.append(",PROCESSINGFEE ");
				sql.append(",BALANCE_AFTER_RECHARGE ");
				sql.append(",CARD_GROUP ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
				}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
					/*If RequestType is POSTPAID,fetch transaction data from Postpaid table*/
					sql.append(",SELFCARE_STATUS");	
					sql.append(",BALANCE_AFTER_TRANS ");
					sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));	
				}
		
			} else {
				sql.append("SELECT * from(select a.*,ROW_NUMBER() over() rnum FROM (");
				sql.append(queryMap.get(SQL_CUST_TRAN_REPORT_DATA_KEY));
				if((mtDTO.getRequestType().getValue())==RequestType.RECHARGE.ordinal()){
				sql.append(",VALIDITY");
				sql.append(",IN_STATUS ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
				}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
						||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
					/*If RequestType is POSTPAID,fetch transaction data from Postpaid table*/
					sql.append(",SELFCARE_STATUS");	
					/*If RequestType is POSTPAID,fetch transaction data from Postpaid table*/
					 sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));	
				}
			}

			sql.append(queryMap.get(SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_KEY));
			params.add(Integer.valueOf(circleId));
		//	params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
			params.add(Utility.getSqlDate(startDt));
			params.add(Utility.getSqlDate(endDt));
		}

		/*If RequestType is POSTPAID,append TRANSACTION TYPE*/
		if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
				||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
				||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
			sql.append(" AND TRANS_TYPE = ?");
			params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
		}
		
		if (transId == null) {
			/*if (circleId != 0) {
				// if circle user
				sql.append(queryMap
						.get(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY));
				params.add(Integer.valueOf(circleId));
			}*/
		
			/* if status is other than 'all'*/
			if (Integer.parseInt(status) != 4) {
				/* Append Transaction status for successful,failed,duplicate or blackout transaction*/
				if (Integer.parseInt(status) == Integer
						.valueOf(TransactionStatus.SUCCESS.ordinal())) {
					sql.append(" AND TRANS_STATUS = ? ");
					params.add(Integer.valueOf(TransactionStatus.SUCCESS
							.ordinal()));
				} else if (Integer.parseInt(status) == Integer
						.valueOf(TransactionStatus.FAILURE.ordinal())) {
					sql.append(" AND TRANS_STATUS IN (?, ?, ?) ");
					params.add(Integer.valueOf(TransactionStatus.FAILURE
							.ordinal()));
					params.add(Integer.valueOf(TransactionStatus.DUPLICATE
							.ordinal()));
					params.add(Integer.valueOf(TransactionStatus.BLACKOUT
							.ordinal()));

				/* Append Transaction status for pending transaction*/
				} else if (Integer.parseInt(status) == Integer
						.valueOf(TransactionStatus.PENDING.ordinal())) {
					sql.append(" AND TRANS_STATUS = ? ");
					params.add(Integer.valueOf(TransactionStatus.PENDING
							.ordinal()));
				}
			}
			
			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					// search according to parent account
					if (Constants.USER_TYPE_EXTERNAL.equalsIgnoreCase(ctx
							.getType())) {
						sql
								.append(queryMap
										.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY));
						params.add(Long.valueOf(ctx.getId()));
						params.add(searchValue);
					} else {
						sql
								.append(queryMap
										.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY));
						params.add(searchValue);
					}

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to User Name*/ 
					if (circleId != 0
							&& Constants.USER_TYPE_EXTERNAL
									.equalsIgnoreCase(ctx.getType())) {
						// sql.append(queryMap.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
						sql
								.append(queryMap
										.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
						params.add(Long.valueOf(ctx.getId()));
					} 
					sql
							.append(queryMap
									.get(SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER_KEY));
					params.add(searchValue.toUpperCase() + "%");
					logger
							.debug(" this is the SQL for Successfull transaction :---- "
									+ sql.toString());

				}
			}
			if (!isExport){
				/*add upper and lower bounds for pagination*/
				sql.append(" order by TRANS_ID desc ");
				sql.append(") a)b Where rnum<=? AND rnum>=?");
				params.add(upperBound);
				params.add(lowerBound + 1);
			}
		}		
		
		
		logger.info("sql="+sql.toString());
		return sql;


}
	
	
	
	/** this function is used to build query for Transaction Summary report
	 * @param mtDTO
	 * @param params
	 * @return
	 */
	private StringBuilder buildTransactionSummaryQuery(ReportInputs mtDTO,
			List<Object> params, TransactionStatus status,
			boolean getTransactionMessage) {
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();

		StringBuilder sql = new StringBuilder();
		if (getTransactionMessage) {
			sql.append(queryMap.get(SQL_FETCH_ESP_SELECT_CLAUSE_KEY));
		} else {
			sql.append(queryMap.get(SQL_FETCH_TRANS_SUMMARY_REPORT_SELECT_CLAUSE_KEY));
		}
		
		if(mtDTO.getRequestType()!= null){
			/*If RequestType is Recharge, fetch transaction data from Recharge report Table*/
			if(mtDTO.getRequestType().getValue()==RequestType.RECHARGE.ordinal()){
				sql.append(" ,SUM(TRANS_AMOUNT) TRANSACTION_AMT ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
							
			}else if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()){
				/*If Request Type is Postpaid, fetch transaction data from postpaid report Table*/
				sql.append(" ,SUM(TRANS_AMOUNT) TRANSACTION_AMT ");
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));
				
			}
			else if(mtDTO.getRequestType().getValue()== RequestType.QUERY.ordinal()){
				sql.append(queryMap.get(SQL_FETCH_TRAN_FROM_QUERY_CLAUSE_KEY));
			}			
		}
		
		
		/*Where clause for SQL Query*/
		sql.append(queryMap.get(SQL_FETCH_TRAN_WHERE_CLAUSE_KEY));

		//params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
		params.add(Utility.getSqlDate(startDt));
		params.add(Utility.getSqlDate(endDt));

		/*If RequestType is POSTPAID,append TRANSACTION TYPE*/
		if(mtDTO.getRequestType()!= null){
			if(mtDTO.getRequestType().getValue()==RequestType.POSTPAID_MOBILE.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_ABTS.ordinal()
					||mtDTO.getRequestType().getValue()==RequestType.POSTPAID_DTH.ordinal()
					|| mtDTO.getRequestType().getValue()==RequestType.QUERY.ordinal()){
				sql.append(" AND TRANS_TYPE = ?");
				params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
			}
		}
//		/*If circle user or external user append circleid*/
//		if (circleId != 0) {
//			sql
//					.append(queryMap
//							.get(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY));
//			params.add(Integer.valueOf(circleId));
//		}
		
		/* Append Transaction status for successful,failed,duplicate or blackout transaction*/
		if (status == TransactionStatus.SUCCESS) {
			sql.append(" AND TRANS_STATUS IN (?) ");
			logger.info(TransactionStatus.SUCCESS.ordinal());
			params.add(Integer.valueOf(TransactionStatus.SUCCESS.ordinal()));
		} else if (status == TransactionStatus.FAILURE) {
			sql.append(" AND TRANS_STATUS IN (?, ?, ?) ");
			params.add(Integer.valueOf(TransactionStatus.FAILURE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.DUPLICATE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.BLACKOUT.ordinal()));
		}
		if (searchType != null) {
			logger.info("2=" + params +  "and " + sql.toString());
			if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_PARENT_CODE)) {
				/* search according to parent account */
				if (Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY));
					params.add(Long.valueOf(ctx.getId()));
					params.add(searchValue);
				} else {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY));
					params.add(searchValue);
				}
			} else if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
				/* search according to User Name*/ 
				if (circleId != 0 && Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRANS_REPORT_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
					params.add(Long.valueOf(ctx.getId()));
				}
				sql.append(queryMap
						.get(SQL_FETCH_TRANSACTION_REPORT_WHERE_CLAUSE_SEARCH_BY_USER_KEY));
				params.add(searchValue.toUpperCase() + "%");
				logger.info(sql.toString());
				logger
						.info(" this iss the SQL for Successfull transaction :---- "
								+ sql.toString());

			}
		}
		logger.info("10=" + params + " and sql" + sql);
		return sql;
	}


	/** this function is use to build query for A2A summary report
	 * @param mtDTO
	 * @param params
	 * @return
	 */
	private StringBuilder buildTransactionA2ASummaryQuery(ReportInputs mtDTO,
			List<Object> params, TransactionStatus status) {
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();

		StringBuilder sql = new StringBuilder();
		
		sql.append(queryMap.get(SQL_FETCH_TRAN_SELECT_CLAUSE_KEY));
		sql.append(queryMap.get(SQL_FETCH_TRAN_WHERE_CLAUSE_KEY));
				
	//	params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
		params.add(Utility.getSqlDate(startDt));
		params.add(Utility.getSqlDate(endDt));

//		/*If circle user or external user append circleid*/
//		if (circleId != 0) {
//			sql
//					.append(queryMap
//							.get(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A_KEY));
//			params.add(Integer.valueOf(circleId));
//		}
		/* Append Transaction status for successful,failed,duplicate or blackout transaction*/
		if (status == TransactionStatus.SUCCESS) {
			sql.append(" AND TRANS_STATUS IN (?) ");
			logger.info(TransactionStatus.SUCCESS.ordinal());
			params.add(Integer.valueOf(TransactionStatus.SUCCESS.ordinal()));
		} else if (status == TransactionStatus.FAILURE) {
			sql.append(" AND TRANS_STATUS IN (?, ?, ?) ");
			params.add(Integer.valueOf(TransactionStatus.FAILURE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.DUPLICATE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.BLACKOUT.ordinal()));
		}
		if (searchType != null) {
			logger.info("2=" + params +  "and " + sql.toString());
			if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_PARENT_CODE)) {
				/* search according to parent account */
				if (Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY));
					params.add(Long.valueOf(ctx.getId()));
					params.add(searchValue);
				} else {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY));
					params.add(searchValue);
				}
			} else if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
				/* search according to user name/account code */
				if (circleId != 0 && Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
					params.add(Long.valueOf(ctx.getId()));
				}
				sql.append(queryMap
						.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER_KEY));
				params.add(searchValue.toUpperCase() + "%");
				logger.info(sql.toString());
				logger
						.info(" this iss the SQL for Successfull transaction :---- "
								+ sql.toString());

			}
		}
		logger.info("10=" + params + " and sql" + sql);
		return sql;
	}

	
	/*
	 * this function is use to  make a query for getting  A2A transaction report data 
	 */
		
	private StringBuilder buildA2ATransactionQuery(ReportInputs mtDTO,
			List<Object> params,boolean isExport,int upperBound,int lowerBound) {
		logger.info(" started  mtDTO :"+mtDTO.toString());
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();
		String status = mtDTO.getStatus();
		
		StringBuilder sql = new StringBuilder();
		
		if(isExport==false){
		   sql.append("SELECT * from(select a.*,ROW_NUMBER() over() rnum FROM (");
		   sql.append(queryMap.get(SQL_FETCH_TRAN_SELECT_A2A_CLAUSE_KEY));
		   sql.append(queryMap.get(SQL_FETCH_TRAN_A2A_WHERE_CLAUSE_KEY));
		}else{
			 sql.append(queryMap.get(SQL_FETCH_TRAN_SELECT_A2A_EXPORT_CLAUSE_KEY));
			 sql.append(queryMap.get(SQL_FETCH_TRAN_A2A_WHERE_EXPORT_CLAUSE_KEY));
							
		}
		params.add(Utility.getSqlDate(startDt));
		params.add(Utility.getSqlDate(endDt));
		
//		/*If circle user or external user append circleid*/
//		if (circleId != 0) {
//			sql
//					.append(queryMap
//							.get(SQL_FETCH_TRAN_WHERE_CLAUSE_CIRCLEUSER_A2A_KEY));
//			params.add(Integer.valueOf(circleId));
//		}
		/* Append Transaction status for successful,failed,duplicate or blackout transaction*/
		if (Integer.parseInt(status) == TransactionStatus.SUCCESS.ordinal()) {
			sql.append(" AND TRANS_STATUS IN (?) ");
			params.add(Integer.valueOf(TransactionStatus.SUCCESS.ordinal()));
		} else if (Integer.parseInt(status) == TransactionStatus.FAILURE.ordinal()) {
			sql.append(" AND TRANS_STATUS IN (?, ?, ?) ");
			params.add(Integer.valueOf(TransactionStatus.FAILURE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.DUPLICATE.ordinal()));
			params.add(Integer.valueOf(TransactionStatus.BLACKOUT.ordinal()));
		}else if (Integer.parseInt(status) == TransactionStatus.PENDING.ordinal()) {
			/* Append Transaction status for pending transaction*/
			sql.append(" AND TRANS_STATUS IN (?) ");
			params.add(Integer.valueOf(TransactionStatus.PENDING.ordinal()));
		}
		if (searchType != null) {
			logger.info("2=" + params +  "and " + sql.toString());
			if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_PARENT_CODE)) {
				/* search according to parent account */
				if (Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_EXT_USERS_KEY));
					params.add(Long.valueOf(ctx.getId()));
					params.add(searchValue);
				} else {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_PNT_ACC_CODE_KEY));
					params.add(searchValue);
				}
			} else if (searchType.trim().equalsIgnoreCase(
					Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
				/* search according to User Name */
				if (circleId != 0 && Constants.USER_TYPE_EXTERNAL
						.equalsIgnoreCase(ctx.getType())) {
					sql
							.append(queryMap
									.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_ACC_CODE_KEY));
					params.add(Long.valueOf(ctx.getId()));
				}
				sql.append(queryMap
						.get(SQL_FETCH_TRAN_WHERE_CLAUSE_SEARCH_BY_USER_KEY));
				params.add(searchValue.toUpperCase() + "%");
				logger.info(sql.toString());
				logger
						.info(" this is the SQL for Successfull transaction :---- "
								+ sql.toString());

			}
			/*add upper and lower bounds for pagination*/
			if(isExport==false){
				sql.append(") a)b Where rnum<=? AND rnum>=?");	
				params.add(upperBound);
				params.add(lowerBound+1);
			}
		}
		logger.info("10=" + params + " and sql" + sql);
		return sql;
	}

	
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getTransactionSummaryRptChildData(com.ibm.virtualization.recharge.dto.ReportInputs)
	 */

	// if not internal user
	public ArrayList getTransactionSummaryRptChildData(ReportInputs mtDTO)
			throws DAOException {
		logger.info("Started..." + mtDTO.toString());
		/* get the data from the input DTO */
		String searchType = mtDTO.getSearchFieldName();
		String searchValue = mtDTO.getSearchFieldValue();
		long parentId = mtDTO.getParentId();
		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		PreparedStatement ps = null;
		PreparedStatement pstmt = null;
		PreparedStatement pstmtTotalTran = null;
		ResultSet rs = null;

		Account2AccountTransferReport acc2accTransferReport = null;
		ArrayList<Account2AccountTransferReport> transactionSumReportList = new ArrayList<Account2AccountTransferReport>();

		try {
			StringBuilder sql = new StringBuilder();
			int paramCount = 1;
			double espCommission = 0.0;
			/**
			 * if status is null then show all successful as well as failure
			 * transactions
			 */
			sql.append(queryMap
					.get(SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE_KEY));
			sql.append(" AND TRANS.TRANS_STATUS = 0 ");
			// for successful transaction start
			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}
			sql.append(" OR  TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			if (0 != circleId) {
				// if circle user, show records of respective circle
				sql.append(" AND DETAILS.CIRCLE_ID = ").append(circleId);

			}
			// if Administrator , show records from all circles
			sql
					.append(" AND TRANS_TYPE = ")
					.append(mtDTO.getRequestType().getValue())
					.append(
							" AND TRUNC(TRANS.CREATED_DATE) >= ? AND TRUNC(TRANS.CREATED_DATE) <= ?");

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					sql
							.append(" AND DETAILS1.ACCOUNT_ID IN(SELECT LOGIN_ID FROM VR_LOGIN_MASTER WHERE UPPER(LOGIN_NAME) LIKE ?)");

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					sql.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");
				}
				ps = connection.prepareStatement(sql.toString());

				ps.setLong(paramCount++, parentId);
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				acc2accTransferReport = new Account2AccountTransferReport();
				acc2accTransferReport.setNoSuccessfulTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				acc2accTransferReport.setValueSuccessfulTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				acc2accTransferReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));

				acc2accTransferReport.setTransactionType(mtDTO.getRequestType()
						.name());

				logger.info("TOTAL_TRANSATCIONS..."
						+ rs.getLong("TOTAL_TRANSCTIONS"));
				logger.info("TRANSACTION_AMT..."
						+ rs.getDouble("TRANSACTION_AMT"));
				logger.info("TOTAL_TRANSATCIONS..."
						+ rs.getLong("TOTAL_TRANSCTIONS"));
			}
			// end of successful transaction

			// start of failure
			StringBuilder sqlFailure = new StringBuilder();
			paramCount = 1;
			sql.append(queryMap
					.get(SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE_KEY));
			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {

				sqlFailure.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				sqlFailure.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());

			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				sqlFailure.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}
			sqlFailure.append(" OR  TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");

			sqlFailure.append(" AND TRANS_TYPE = ").append(
					mtDTO.getRequestType().getValue());
			sqlFailure.append("  AND TRANS.TRANS_STATUS = 2 ");

			if (0 != circleId) {
				// if circle user, show records of respective circle
				sqlFailure.append(" AND DETAILS.CIRCLE_ID = ").append(circleId);
			}
			// if Administrator , show records from all circles
			sqlFailure
					.append("  AND TRUNC(TRANS.CREATED_DATE) >= ? AND TRUNC(TRANS.CREATED_DATE) <= ?");

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					sqlFailure
							.append(" AND DETAILS.PARENT_ACCOUNT=LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					sqlFailure.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");

				}
				ps = connection.prepareStatement(sqlFailure.toString());

				ps.setLong(paramCount++, parentId);
				ps.setDate(paramCount++, Utility.getSqlDate(startDt));
				ps.setDate(paramCount++, Utility.getSqlDate(endDt));
				ps.setString(paramCount++, searchValue.toUpperCase() + "%");
			}
			rs = ps.executeQuery();

			while (rs.next()) {
				// acc2accTransferReport = new Account2AccountTransferReport();
				acc2accTransferReport.setNoFailedTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));
				acc2accTransferReport.setValueFailedTransaction(rs
						.getDouble("TRANSACTION_AMT"));
				acc2accTransferReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));

				logger.info("FailedTransaction TOTAL_TRANSATCIONSq..."
						+ rs.getLong("TOTAL_TRANSCTIONS"));
				logger.info("FailedTransaction TRANSACTION_AMTq..."
						+ rs.getDouble("TRANSACTION_AMT"));
				logger.info("FailedTransaction TOTAL_TRANSATCIONSq..."
						+ rs.getLong("TOTAL_TRANSCTIONS"));

				// acc2accTransferReport.setTransactionType(mtDTO.getTransactionType().name());
			}

			// end of failure

			// total
			StringBuilder msgDetailsQuery = new StringBuilder();
			int msgParamCount = 1;
			/**
			 * if status is null then show all successful as well as failure
			 * transactions
			 */
			msgDetailsQuery.append(queryMap
					.get(SQL_ALL_CHILD_TRANSFER_SUMMARY_REPORT_RECHARGE_KEY));
			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {

				msgDetailsQuery.append(" AND TDETAIL.TRANS_STATE = ").append(
						TransactionState.RECHARGE_REQUEST_LISTENER.getValue());

			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				msgDetailsQuery.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.POSTPAID_REQUEST_LISTENER.getValue());

			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				msgDetailsQuery.append(" AND ( TDETAIL.TRANS_STATE = ").append(
						TransactionState.VAS_REQUEST_LISTENER.getValue());

			}

			msgDetailsQuery.append(" OR  TDETAIL.TRANS_STATE = ").append(
					TransactionState.WEB.getValue()).append(" ) ");
			msgDetailsQuery.append(" AND TRANS.TRANS_STATUS = ?   ");

			if (0 != circleId) {
				// if circle user, show records of respective circle
				msgDetailsQuery.append(" AND DETAILS.CIRCLE_ID = ").append(
						circleId);

			}
			// if Administrator , show records from all circles
			msgDetailsQuery
					.append(" AND TRANS_TYPE = ")
					.append(mtDTO.getRequestType().getValue())
					.append(
							" AND TRUNC(TRANS.CREATED_DATE) >= ? AND TRUNC(TRANS.CREATED_DATE) <= ?");

			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					msgDetailsQuery
							.append(" AND DETAILS.PARENT_ACCOUNT=LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					msgDetailsQuery
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");
				}
				pstmt = connection.prepareStatement(msgDetailsQuery.toString());

				ps.setLong(paramCount++, parentId);
				pstmt.setInt(msgParamCount++, 0);
				// pstmt.setInt(msgParamCount++, 2);
				pstmt.setDate(msgParamCount++, Utility.getSqlDate(startDt));
				pstmt.setDate(msgParamCount++, Utility.getSqlDate(endDt));
				pstmt.setString(msgParamCount++, searchValue.toUpperCase()
						+ "%");
			}
			rs = pstmt.executeQuery();
			while (rs.next()) {
				espCommission = espCommission
						+ Utility.parseMessage(rs.getString("DETAIL_MSG"),
								"espCommission");
				logger.info("Esp Commission : " + espCommission);
			}
			acc2accTransferReport.setTotalEspCommission(espCommission);

			StringBuilder totalTransactionsQuery = new StringBuilder();
			int totalTranCount = 1;
			totalTransactionsQuery.append(queryMap
					.get(SQL_TRANSFER_SUMMARY_CHILD_COUNT_RECHARGE_KEY));
			if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
					.getValue()) {
				totalTransactionsQuery.append(" AND ( TDETAIL.TRANS_STATE = ")
						.append(
								TransactionState.RECHARGE_REQUEST_LISTENER
										.getValue());
			} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
					.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
							.ordinal()
					|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
							.ordinal()) {
				totalTransactionsQuery.append(" AND ( TDETAIL.TRANS_STATE = ")
						.append(
								TransactionState.POSTPAID_REQUEST_LISTENER
										.getValue());

			} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
					.getValue()) {
				totalTransactionsQuery.append(" AND ( TDETAIL.TRANS_STATE = ")
						.append(
								TransactionState.VAS_REQUEST_LISTENER
										.getValue());

			}
			totalTransactionsQuery.append(" OR  TDETAIL.TRANS_STATE = ")
					.append(TransactionState.WEB.getValue()).append(" ) ");

			if (0 != circleId) {
				// if circle user, show records of respective circle
				totalTransactionsQuery.append(" AND DETAILS.CIRCLE_ID = ")
						.append(circleId);
			}
			totalTransactionsQuery.append(" AND TRANS_TYPE = ").append(
					mtDTO.getRequestType().getValue());
			totalTransactionsQuery
					.append(" AND TRUNC(TRANS.CREATED_DATE) >= ? AND TRUNC(TRANS.CREATED_DATE) <= ?");
			if (searchType != null) {
				if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_PARENT_CODE)) {
					/* search according to parent account */
					totalTransactionsQuery
							.append(" AND DETAILS.PARENT_ACCOUNT=LOGIN1.LOGIN_ID AND UPPER(LOGIN1.LOGIN_NAME) LIKE ? ");

				} else if (searchType.trim().equalsIgnoreCase(
						Constants.SEARCH_TYPE_ACCOUNT_CODE)) {
					/* search according to account code */
					totalTransactionsQuery
							.append(" AND UPPER(LOGIN.LOGIN_NAME) LIKE ?");

				}
				pstmtTotalTran = connection
						.prepareStatement(totalTransactionsQuery.toString());

				ps.setLong(paramCount++, parentId);
				pstmtTotalTran.setDate(totalTranCount++, Utility
						.getSqlDate(startDt));
				pstmtTotalTran.setDate(totalTranCount++, Utility
						.getSqlDate(endDt));
				pstmtTotalTran.setString(totalTranCount++, searchValue
						.toUpperCase()
						+ "%");
			}
			rs = pstmtTotalTran.executeQuery();
			while (rs.next()) {
				acc2accTransferReport.setTotalTransaction(rs
						.getLong("TOTAL_TRANSCTIONS"));

			}

			transactionSumReportList.add(acc2accTransferReport);
		} catch (SQLException e) {
			logger.error("Exception occured while reteriving.Account List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} finally {
			/* Close the statement,resultset for success or failure transactions */
			DBConnectionManager.releaseResources(ps, rs);
			/* Close the statement,resultset for msg detail query */
			DBConnectionManager.releaseResources(pstmt, rs);
			/* Close the statement,resultset for total transations */
			DBConnectionManager.releaseResources(pstmtTotalTran, rs);
		}
		logger.info("Executed  ...");
		return transactionSumReportList;
	}

	
	/*
	 * (non-Javadoc)
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getCustomerTransactionListWithId(java.lang.String)
	 */
	public ArrayList getCustomerTransactionListWithId(String transactionId,String transType) throws DAOException {

		logger.info("Started getCustomerTransactionList()...");

		/** get the data from the input DTO */
		PreparedStatement ps = null;
		ResultSet rs = null;
		/** use to store DTO objects */
		ArrayList<CustomerTransaction> results = new ArrayList<CustomerTransaction>();
		CustomerTransaction customerTransaction = null;
		StringBuilder sql = new StringBuilder();
		try {
			int paramCount = 1;
			sql.append(queryMap.get(SQL_SELECT_CUSTOMER_TRANSACTION_WITH_ID_KEY));
			
			if (RequestType.valueOf(transType).getValue()== RequestType.RECHARGE
					.getValue()) {
				sql.append(" AND ( TDETAIL.TRANS_STATE ="+TransactionState.RECHARGE_REQUEST_LISTENER.getValue()+ " OR  TDETAIL.TRANS_STATE = "+ TransactionState.WEB.getValue()+")" );
				
			}else {
				sql.append(" AND ( TDETAIL.TRANS_STATE ="+TransactionState.POSTPAID_REQUEST_LISTENER.getValue()+ " OR  TDETAIL.TRANS_STATE = "+ TransactionState.WEB.getValue()+")" );
				
			}
			
			logger.info("Final Query is "+sql.toString());
			ps = connection.prepareStatement(sql.toString());
			ps.setInt(paramCount, Integer.valueOf(transactionId));
			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
	

				// Send the Transaction Status ordinal value instead of constant
				// charachers.
				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));
				
				String inStatus = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_IN_STATUS));
		        customerTransaction.setInStatus(inStatus);

				customerTransaction.setReason(rs.getString("REASON_ID"));
				
					customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
				
			
				String message = rs.getString("DETAIL_MSG");
				
				String ConfirmMobileNo = Utility.parseMessageString(message, Constants.REPORT_CONFIRM_MOBILE_NUMBER);
				logger.info("ConfirmMobileNo " + ConfirmMobileNo);
				customerTransaction.setConfirmMobileNo(ConfirmMobileNo);
				double serviceTax = Utility.parseMessage(message, Constants.REPORT_SERVICE_TAX_START);
				logger.info("serviceTax : " + serviceTax);
				customerTransaction.setServiceTax(serviceTax);

				double espCommission = Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("espCommission : " + espCommission);
				customerTransaction.setEspCommission(espCommission);

				double processingFee = Utility.parseMessage(message, Constants.REPORT_PROCESSING_FEE_START);
				logger.info("processingFee : " + processingFee);
				customerTransaction.setProcessingFee(processingFee);
				
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"), ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				logger.info("validity : " + validity);
				customerTransaction.setValidity(validity);
				

				double talkTime = Utility.parseMessage(message, Constants.REPORT_TALK_TIME_START);
				logger.info("talkTime : " + talkTime);
				customerTransaction.setTalkTime(talkTime);
				
				/** adding each DTO object into array List */
				results.add(customerTransaction);
			}
		} catch (SQLException e) {
			logger
					.fatal(
							"Exception occured while reteriving customer transation list for internal user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		}catch(VirtualizationServiceException virtualizationExp){
			logger.error("DistributorTransactionDaoRdbmsDB2:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}
		finally {
			/** Close the preparedstatement,resultset. */
			DBConnectionManager.releaseResources(ps, rs);
		}

		logger
				.info("Executed getCustomerTransactionList().... Customer Transaction List SuccessFully Retreived");
		return results;

	}

	/**
	 * This method will be used provide a list of customer transactions for
	 * internal user logged in.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * @param lowerBound -
	 *            specifies the number from which to fetch the records.
	 * @param upperBound -
	 *            specifies the number up to which to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getCustomerTransactionList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {

		logger.info("Started getCustomerTransactionList()...");

		/** get the data from the input DTO */
		String searchFieldValue = mtDTO.getSearchFieldValue();
		int tranId = 0;
		if (searchFieldValue != null && !searchFieldValue.equals("")) {
			tranId = Integer.parseInt(searchFieldValue);
		}
		int tranType;
		if (null != mtDTO.getRequestType()) {
			tranType = mtDTO.getRequestType().getValue();
		} else {
			tranType = -1;
		}

		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		/** use to store DTO objects */
		ArrayList<CustomerTransaction> results = new ArrayList<CustomerTransaction>();
		CustomerTransaction customerTransaction = null;
		StringBuilder query = new StringBuilder();
		StringBuilder sql = new StringBuilder();
		try {
			int paramCount = 1;
			sql.append(queryMap.get(SQL_SELECT_CUSTOMER_TRANSACTION_KEY));

			if (0 != circleId) {
				/** if circle user, show records of respective circle */
				sql.append(" AND DETAILS.CIRCLE_ID = ");
				sql.append(circleId);
			}

			if (-1 != tranType) {
				sql.append(" AND TRANS.TRANS_TYPE LIKE ?");
				if (tranType == RequestType.RECHARGE.getValue()) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.RECHARGE_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				} else if ((tranType == RequestType.POSTPAID_MOBILE.getValue())||(tranType == RequestType.POSTPAID_ABTS.getValue())||(tranType == RequestType.POSTPAID_DTH.getValue())) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.POSTPAID_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				}
				/*
				 * else if(tranType == RequestType.VAS.getValue()){ sql.append("
				 * AND (TDETAIL.TRANS_STATE = " +
				 * TransactionState.VAS_REQUEST_LISTENER.getValue() + " OR
				 * TDETAIL.TRANS_STATE = " + TransactionState.WEB.getValue() +
				 * ")"); }
				 */
			} else {
				sql
						.append(" AND TDETAIL.TRANS_STATE = (SELECT MIN(TDETAIL1.TRANS_STATE) FROM VR_TRANS_DETAIL TDETAIL1  WHERE TDETAIL1.TRANS_ID = TDETAIL.TRANS_ID)");
			}

			if (0 != tranId) {
				/** search according to Transaction Id */
				sql.append(" AND UPPER(TRANS.TRANS_ID) LIKE ? ");
			}
			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) <= ? ");
			}
			sql.append(" ORDER BY TRANS.TRANS_ID DESC");
			/** apply the pagination query */
			query.append("SELECT * FROM  ( SELECT a.*, ROW_NUMBER() over() rnum FROM ( ");
			query.append(sql);
			query.append(" )a ) b WHERE rnum<=? AND rnum>=? ");
			ps = connection.prepareStatement(query.toString());

			/** set the values in the statement */
			if (-1 != tranType) {
				ps.setInt(paramCount++, tranType);
			}

			if (0 != tranId) {
				ps.setInt(paramCount++, tranId);
			}
			if (startDt != null && !startDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						startDt).getTime()));
			}
			if (endDt != null && !endDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						endDt).getTime()));
			}
			ps.setString(paramCount++, String.valueOf(upperBound));
			ps.setString(paramCount++, String.valueOf(lowerBound + 1));

			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				customerTransaction.setTotalRecords(rs.getInt("RECORD_COUNT"));

				// Send the Transaction Status ordinal value instead of constant
				// charachers.
				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));

				/*
				 * if (TransactionStatus.SUCCESS.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_SUCCESS); } else if
				 * (TransactionStatus.PENDING.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_IN_PROGRESS); } else if
				 * (TransactionStatus.FAILURE.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_FAILURE); }
				 */
				customerTransaction.setReason(rs.getString("REASON_ID"));
				customerTransaction.setRowNum(rs.getString("RNUM"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"), ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				logger.info("validity : " + validity);
				customerTransaction.setValidity(validity);
				
				customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
				

				String message = rs.getString("DETAIL_MSG");
				double serviceTax = Utility.parseMessage(message, Constants.REPORT_SERVICE_TAX_START);
				logger.info("serviceTax : " + serviceTax);
				customerTransaction.setServiceTax(serviceTax);

				double espCommission = Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("espCommission : " + espCommission);
				customerTransaction.setEspCommission(espCommission);

				double processingFee = Utility.parseMessage(message, Constants.REPORT_PROCESSING_FEE_START);
				logger.info("processingFee : " + processingFee);
				customerTransaction.setProcessingFee(processingFee);

				double talkTime = Utility.parseMessage(message, Constants.REPORT_TALK_TIME_START);
				logger.info("talkTime : " + talkTime);
				customerTransaction.setTalkTime(talkTime);

				/** adding each DTO object into array List */
				results.add(customerTransaction);
			}

		} catch (SQLException e) {
			logger
					.fatal(
							"Exception occured while reteriving customer transation list for internal user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("DistributorTransactionDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		}finally {
			/** Close the preparedstatement,resultset. */
			DBConnectionManager.releaseResources(ps, rs);
		}

		logger
				.info("Executed getCustomerTransactionList().... Customer Transaction List SuccessFully Retreived");
		return results;
	}

	/**
	 * This method will be used provide a list of all customer transactions for
	 * internal user logged in. This will provide all the records and is
	 * independent of pagination logic.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getCustomerTransactionListAll(ReportInputs mtDTO)
			throws DAOException {
		logger.info("Started getCustomerTransactionListAll()...");

		/** get the data from the input DTO */
		String searchFieldValue = mtDTO.getSearchFieldValue();
		int tranId = 0;
		if (searchFieldValue != null && !searchFieldValue.equals("")) {
			tranId = Integer.parseInt(searchFieldValue);
		}
		int tranType;
		if (null != mtDTO.getRequestType()) {
			tranType = mtDTO.getRequestType().getValue();
		} else {
			tranType = -1;
		}
		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		/** use to store DTO objects */
		ArrayList<CustomerTransaction> results = new ArrayList<CustomerTransaction>();
		CustomerTransaction customerTransaction = null;
		StringBuilder sql = new StringBuilder();
		try {
			int paramCount = 1;
			sql.append(queryMap.get(SQL_SELECT_CUSTOMER_TRANSACTION_KEY));

			if (0 != circleId) {
				/** if circle user, show records of respective circle */
				sql.append(" AND DETAILS.CIRCLE_ID = ");
				sql.append(circleId);
			}
			if (-1 != tranType) {
				sql.append(" AND TRANS.TRANS_TYPE LIKE ?");
				if (tranType == RequestType.RECHARGE.getValue()) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.RECHARGE_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				} else if ((tranType == RequestType.POSTPAID_MOBILE.getValue())||(tranType == RequestType.POSTPAID_ABTS.getValue())||(tranType == RequestType.POSTPAID_DTH.getValue())) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.POSTPAID_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				}
				/*
				 * else if(tranType == RequestType.VAS.getValue()){ sql.append("
				 * AND (TDETAIL.TRANS_STATE = " +
				 * TransactionState.VAS_REQUEST_LISTENER.getValue() + " OR
				 * TDETAIL.TRANS_STATE = " + TransactionState.WEB.getValue() +
				 * ")"); }
				 */
			} else {
				sql
						.append(" AND TDETAIL.TRANS_STATE = (SELECT MIN(TDETAIL1.TRANS_STATE) FROM VR_TRANS_DETAIL TDETAIL1  WHERE TDETAIL1.TRANS_ID = TDETAIL.TRANS_ID)");
			}
			if (0 != tranId) {
				/** search according to Transaction Id */
				sql.append(" AND UPPER(TRANS.TRANS_ID) LIKE ? ");
			}
			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) <= ? ");
			}
			sql.append(" ORDER BY TRANS.TRANS_ID DESC");
			ps = connection.prepareStatement(sql.toString());

			/** set the values in the statement */
			if (-1 != tranType) {
				ps.setInt(paramCount++, tranType);
			}
			if (0 != tranId) {
				ps.setInt(paramCount++, tranId);
			}
			if (startDt != null && !startDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						startDt).getTime()));
			}
			if (endDt != null && !endDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						endDt).getTime()));
			}
			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				// Send the Transaction Status ordinal value instead of constant
				// charachers.
				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));

				/*
				 * if (TransactionStatus.SUCCESS.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_SUCCESS); } else if
				 * (TransactionStatus.PENDING.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_IN_PROGRESS); } else if
				 * (TransactionStatus.FAILURE.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_FAILURE); }
				 */
				customerTransaction.setReason(rs.getString("REASON_ID"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"), ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				logger.info("validity : " + validity);
				customerTransaction.setValidity(validity);
				
				customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
			
				String message = rs.getString("DETAIL_MSG");
				double serviceTax = Utility.parseMessage(message, Constants.REPORT_SERVICE_TAX_START);
				logger.info("serviceTax : " + serviceTax);
				customerTransaction.setServiceTax(serviceTax);

				double espCommission = Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("espCommission : " + espCommission);
				customerTransaction.setEspCommission(espCommission);

				double processingFee = Utility.parseMessage(message, Constants.REPORT_PROCESSING_FEE_START);
				logger.info("processingFee : " + processingFee);
				customerTransaction.setProcessingFee(processingFee);

				double talkTime = Utility.parseMessage(message, Constants.REPORT_TALK_TIME_START);
				logger.info("talkTime : " + talkTime);
				customerTransaction.setTalkTime(talkTime);

				/** adding each DTO object into array List */
				results.add(customerTransaction);
			}

		} catch (SQLException e) {
			logger
					.fatal(
							"Exception occured while reteriving a list of all customer transactions for internal user logged in."
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		}catch(VirtualizationServiceException virtualizationExp){
			logger.error("DistributorTransactionDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		} finally {
			/** Close the preparedstatement,resultset. */
			DBConnectionManager.releaseResources(ps, rs);
		}

		logger
				.info("Executed getCustomerTransactionListAll().... all Customer Transaction List SuccessFully Retreived");
		return results;
	}


	/**
	 * This method will be used provide a list of customer transactions for
	 * external user logged in.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * @param lowerBound -
	 *            specifies the number from which to fetch the records
	 * @param upperBound -
	 *            specifies the number up to which to fetch the records
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getCustomerChildAccountList(ReportInputs mtDTO,
			int lowerBound, int upperBound) throws DAOException {
		logger.info("Started getCustomerChildAccountList()...");

		/** get the data from the input DTO */
		String searchFieldValue = mtDTO.getSearchFieldValue();
		int tranId = 0;
		if (searchFieldValue != null && !searchFieldValue.equals("")) {
			tranId = Integer.parseInt(searchFieldValue);
		}
		int tranType;
		if (null != mtDTO.getRequestType()) {
			tranType = mtDTO.getRequestType().getValue();
		} else {
			tranType = -1;
		}

		long parentId = mtDTO.getParentId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		/** use to store DTO objects */
		ArrayList<CustomerTransaction> results = new ArrayList<CustomerTransaction>();
		CustomerTransaction customerTransaction = null;
		StringBuilder query = new StringBuilder();
		StringBuilder sql = new StringBuilder();
		try {
			int paramCount = 1;
			sql.append(queryMap.get(SQL_SELECT_CUSTOMER_TRANSACTION_KEY));
			if (-1 != tranType) {
				sql.append(" AND TRANS.TRANS_TYPE LIKE ?");
				if (tranType == RequestType.RECHARGE.getValue()) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.RECHARGE_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				} else if 
				((tranType == RequestType.POSTPAID_MOBILE.getValue())||(tranType == RequestType.POSTPAID_ABTS.getValue())||(tranType == RequestType.POSTPAID_DTH.getValue())) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.POSTPAID_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				}
				/*
				 * else if(tranType == RequestType.VAS.getValue()){ sql.append("
				 * AND (TDETAIL.TRANS_STATE = " +
				 * TransactionState.VAS_REQUEST_LISTENER.getValue() + " OR
				 * TDETAIL.TRANS_STATE = " + TransactionState.WEB.getValue() +
				 * ")"); }
				 */
			} else {
				sql
						.append(" AND TDETAIL.TRANS_STATE = (SELECT MIN(TDETAIL1.TRANS_STATE) FROM VR_TRANS_DETAIL TDETAIL1  WHERE TDETAIL1.TRANS_ID = TDETAIL.TRANS_ID)");
			}
			if (0 != tranId) {
				/** search according to Transaction Id */
				sql.append(" AND UPPER(TRANS.TRANS_ID) LIKE ? ");
			}
			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) <= ? ");
			}
			sql
					.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ORDER BY TRANS.TRANS_ID DESC ");
			/** apply the pagination query */
//			query.append("SELECT * FROM(SELECT a.*,ROWNUM rnum FROM (");
//			query.append(sql);
//			query.append(") a Where ROWNUM<=?)Where rnum>=?");
			query.append("SELECT * FROM  ( SELECT a.*, ROW_NUMBER() over() rnum FROM ( ");
			query.append(sql);
			query.append(" )a ) b WHERE rnum<=? AND rnum>=? ");
			logger.info("View Customer Transacion Query for External User: "+query.toString());
			ps = connection.prepareStatement(query.toString());

			/** set the values in the statement */
			if (-1 != tranType) {
				ps.setInt(paramCount++, tranType);
			}
			if (0 != tranId) {
				ps.setInt(paramCount++, tranId);
			}
			if (startDt != null && !startDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						startDt).getTime()));
			}
			if (endDt != null && !endDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						endDt).getTime()));
			}
			ps.setLong(paramCount++, parentId);
			ps.setString(paramCount++, String.valueOf(upperBound));
			ps.setString(paramCount++, String.valueOf(lowerBound + 1));

			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				customerTransaction.setTotalRecords(rs.getInt("RECORD_COUNT"));

				// Send the Transaction Status ordinal value instead of constant
				// charachers.
				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));

				/*
				 * if (TransactionStatus.SUCCESS.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_SUCCESS); } else if
				 * (TransactionStatus.PENDING.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_IN_PROGRESS); } else if
				 * (TransactionStatus.FAILURE.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_FAILURE); }
				 */
				customerTransaction.setReason(rs.getString("REASON_ID"));
				customerTransaction.setRowNum(rs.getString("RNUM"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"), ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				logger.info("validity : " + validity);
				customerTransaction.setValidity(validity);

				customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
				



				String message = rs.getString("DETAIL_MSG");
				double serviceTax = Utility.parseMessage(message, Constants.REPORT_SERVICE_TAX_START);
				logger.info("serviceTax : " + serviceTax);
				customerTransaction.setServiceTax(serviceTax);

				double espCommission = Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("espCommission : " + espCommission);
				customerTransaction.setEspCommission(espCommission);

				double processingFee = Utility.parseMessage(message, Constants.REPORT_PROCESSING_FEE_START);
				logger.info("processingFee : " + processingFee);
				customerTransaction.setProcessingFee(processingFee);

				double talkTime = Utility.parseMessage(message, Constants.REPORT_TALK_TIME_START);
				logger.info("talkTime : " + talkTime);
				customerTransaction.setTalkTime(talkTime);

				/** adding each DTO object into array List */
				results.add(customerTransaction);
			}

		} catch (SQLException e) {
			logger
					.fatal(
							"Exception occured while reteriving customer transaction list for external user logged in. "
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("DistributorTransactionDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		} finally {
			/** Close the preparedstatement,resultset. */
			DBConnectionManager.releaseResources(ps, rs);
		}

		logger
				.info("Executed getCustomerChildAccountList().... Customer child Transaction List SuccessFully Retreived");
		return results;
	}

		
	public TransactionReport getTransactionRptListView(int transactionId,String requestType) throws DAOException {
	// TODO Auto-generated method stub
	logger.debug("Started.. transactionId "+transactionId);
	PreparedStatement ps = null;
	ResultSet rs = null;
	TransactionReport transactionReport = null;
	try{
		logger.info("SQL_TRANSACTION_REPORT_VIEW_DATA_KEY :- "+SQL_TRANSACTION_REPORT_VIEW_DATA);
		StringBuilder query = new StringBuilder(queryMap.get(SQL_TRANSACTION_REPORT_VIEW_DATA_KEY));
		/*If RequestType is RECHARGE, fetch transaction data from Recharge Report table*/
		if(requestType.equalsIgnoreCase(RequestType.RECHARGE.name())){
				query.append(",BALANCE_AFTER_RECHARGE ");
				query.append(",IN_STATUS ");
				query.append(",PROCESSINGFEE ");
				query.append(",VALIDITY ");
				query.append(",CARD_GROUP ");
								
				query.append(queryMap.get(SQL_FETCH_TRAN_FROM_RECHARGE_CLAUSE_KEY));
		}else if(requestType.equalsIgnoreCase(RequestType.POSTPAID_MOBILE.name())
				||requestType.equalsIgnoreCase(RequestType.POSTPAID_ABTS.name())
				||requestType.equalsIgnoreCase(RequestType.POSTPAID_DTH.name())){
			/*If Request Type is Postpaid, fetch transaction data from Recharge Table*/
				query.append(",SELFCARE_STATUS ");
				query.append(",BALANCE_AFTER_TRANS ");
				query.append(queryMap.get(SQL_FETCH_TRAN_FROM_POSTPAID_CLAUSE_KEY));
		}
		query.append(" TRANS_ID = ?");
		logger.info(query.toString());
		ps = connection.prepareStatement(query.toString());

		ps.setInt(1, transactionId);
		rs = ps.executeQuery();
		
		
		if (rs.next()) {
			transactionReport = new TransactionReport();
			
			transactionReport.setTransactionId(rs.getLong("TRANS_ID"));
			transactionReport.setTransactionType(TransactionType
					.getTransactionType(rs.getInt("TRANS_TYPE")));
			// transactionReport.setMtpAccountCode(rs.getString("REQUESTER_ID"));
			transactionReport.setMtpAccountCode(rs
					.getString("TRANSFER_ACC_CODE"));
				transactionReport
						.setCustomerMobile(rs.getString("RECEIVER_ID"));
				transactionReport.setParentName(rs.getString("PARENT_NAME1"));
				transactionReport.setParentName1(rs.getString("PARENT_NAME2"));
				transactionReport.setParentName2(rs.getString("PARENT_NAME3"));
				transactionReport.setParentName3(rs.getString("PARENT_NAME4"));
				transactionReport.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
			
				transactionReport.setRequesterMobile(rs.getString("REQ_MOBILE_NUMBER"));
				transactionReport.setReceiverAccountId(rs.getLong("ACCOUNT_ID"));
		      
				transactionReport.setCommission(rs.getDouble("ESPCOMMISSION"));
				
				transactionReport.setServiceTax(rs.getDouble("SERVICETAX"));
				transactionReport.setTalkTime(rs.getDouble("CREDITEDAMOUNT"));
				
				transactionReport.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));
				
				double debitAmount = rs.getDouble("DEBITAMOUNT");
				// set the debit amount
				transactionReport.setDebitAmount(debitAmount);
			
				// subscriberCircleCode
				transactionReport.setSubscriberCircleId(rs.getString("REC_CIRCLE_CODE"));
				// "requesterCircleCode"
				transactionReport.setRequesterCircleId(rs.getString("REQ_CIRCLE_CODE"));
				/*If Request Type is Recharge */
			if(requestType.equalsIgnoreCase(RequestType.RECHARGE.name())){
				
				double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_RECHARGE");
				logger.info("SourcebalanceAfterRecharge : "
							+ availbalAfterRecharge);
					transactionReport
							.setSourceAvailBalAfterRecharge(availbalAfterRecharge);
				double availbalBeforeRecharge = 0.0;
				if (TransactionStatus.SUCCESS.getValue() == rs
						.getInt("TRANS_STATUS")) {
					// to find the Source Operating Balance before
					// recharge
					availbalBeforeRecharge = availbalAfterRecharge
							+ debitAmount;
						
				} else {
						availbalBeforeRecharge = availbalAfterRecharge;
				}
				transactionReport
						.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
				logger.info("SourcebalanceBeforeRecharge : "
						+ availbalBeforeRecharge);
				transactionReport.setInStatus(rs.getString("IN_STATUS"));
				transactionReport.setValidity(rs.getString("VALIDITY"));
				transactionReport.setProcessingFee(rs.getDouble("PROCESSINGFEE"));
				transactionReport.setCardGroup(rs.getString("CARD_GROUP"));
			}else if(requestType.equalsIgnoreCase(RequestType.POSTPAID_MOBILE.name())
					||requestType.equalsIgnoreCase(RequestType.POSTPAID_ABTS.name())
					||requestType.equalsIgnoreCase(RequestType.POSTPAID_DTH.name())){
				
				double availbalAfterRecharge =rs.getDouble("BALANCE_AFTER_TRANS");
				logger.info("SourcebalanceAfterRecharge : "+ availbalAfterRecharge);
					transactionReport.setSourceAvailBalAfterRecharge(availbalAfterRecharge);
				double availbalBeforeRecharge = 0.0;
				if (TransactionStatus.SUCCESS.getValue() == rs
						.getInt("TRANS_STATUS")) {
					// to find the Source Operating Balance before
					// recharge
					availbalBeforeRecharge = availbalAfterRecharge+ debitAmount;
						
				} else {
						availbalBeforeRecharge = availbalAfterRecharge;
				}
				transactionReport.setSourceAvailBalBeforeRecharge(availbalBeforeRecharge);
				logger.info("SourcebalanceBeforeRecharge : "+ availbalBeforeRecharge);
				
				transactionReport.setSelfcareStatus(rs.getString("SELFCARE_STATUS"));
			}
			
			
				transactionReport.setStatus(rs.getInt("TRANS_STATUS"));
				transactionReport.setCreatedBy(rs.getString("CREATED_BY"));
				transactionReport.setReason(rs.getString("REASON_ID"));
		

			}
			logger.debug("Executed .... ");
			return transactionReport;
		}

		catch (SQLException sqle) {
			logger.error(" SQL Exception occured while find."
					+ "Exception Message: " + sqle.getMessage(), sqle);
			throw new DAOException(sqle.getMessage());
		} finally {
			/* Close the resultset, statement. */
			DBConnectionManager.releaseResources(ps, rs);
		}
	
	}


	
	/**
	 * This method will be used provide a list of all customer transactions for
	 * external user logged in. This will provide all the records and is
	 * independent of pagination logic.
	 * 
	 * @param mtDTO -
	 *            reports input dto which will contain all the mandatory
	 *            information required by the dao to fetch the records.
	 * 
	 * @return list - contains the records fetched.
	 * @throws DAOException -
	 *             exception which will be thrown incase any exception occurs
	 *             while fetching the records.
	 */
	public ArrayList getCustomerChildAccountListAll(ReportInputs mtDTO)
			throws DAOException {
		logger.info("Started getCustomerChildAccountListAll()...");

		/** get the data from the input DTO */
		String searchFieldValue = mtDTO.getSearchFieldValue();
		int tranId = 0;
		if (searchFieldValue != null && !searchFieldValue.equals("")) {
			tranId = Integer.parseInt(searchFieldValue);
		}
		int tranType;
		if (null != mtDTO.getRequestType()) {
			tranType = mtDTO.getRequestType().getValue();
		} else {
			tranType = -1;
		}
		long parentId = mtDTO.getParentId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();

		PreparedStatement ps = null;
		ResultSet rs = null;
		/** use to store DTO objects */
		ArrayList<CustomerTransaction> results = new ArrayList<CustomerTransaction>();
		CustomerTransaction customerTransaction = null;
		StringBuilder sql = new StringBuilder();
		try {
			int paramCount = 1;
			sql.append(queryMap.get(SQL_SELECT_CUSTOMER_TRANSACTION_KEY));

			if (-1 != tranType) {
				sql.append(" AND TRANS.TRANS_TYPE LIKE ?");
				if (tranType == RequestType.RECHARGE.getValue()) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.RECHARGE_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				} else if 

				((tranType == RequestType.POSTPAID_MOBILE.getValue())||(tranType == RequestType.POSTPAID_ABTS.getValue())||(tranType == RequestType.POSTPAID_DTH.getValue())) {
					sql.append(" AND (TDETAIL.TRANS_STATE = "
							+ TransactionState.POSTPAID_REQUEST_LISTENER
									.getValue() + " OR TDETAIL.TRANS_STATE = "
							+ TransactionState.WEB.getValue() + ")");
				}
				/*
				 * else if(tranType == RequestType.VAS.getValue()){ sql.append("
				 * AND (TDETAIL.TRANS_STATE = " +
				 * TransactionState.VAS_REQUEST_LISTENER.getValue() + " OR
				 * TDETAIL.TRANS_STATE = " + TransactionState.WEB.getValue() +
				 * ")"); }
				 */
			} else {
				sql
						.append(" AND TDETAIL.TRANS_STATE = (SELECT MIN(TDETAIL1.TRANS_STATE) FROM VR_TRANS_DETAIL TDETAIL1  WHERE TDETAIL1.TRANS_ID = TDETAIL.TRANS_ID)");
			}

			if (0 != tranId) {
				/** search according to Transaction Id */
				sql.append(" AND UPPER(TRANS.TRANS_ID) LIKE ? ");
			}

			if (startDt != null && !startDt.equals("")) {
				/** search according to Start Date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) >= ? ");
			}
			if (endDt != null && !endDt.equals("")) {
				/** search according to End date */
				sql.append(" AND TRUNC(TRANS.TRANS_DATE) <= ? ");
			}
			sql
					.append(" START WITH DETAILS.ACCOUNT_ID = ? CONNECT BY PRIOR DETAILS.ACCOUNT_ID = DETAILS.PARENT_ACCOUNT ORDER BY TRANS.TRANS_ID DESC ");
			ps = connection.prepareStatement(sql.toString());

			/** set the values in the statement */
			if (-1 != tranType) {
				ps.setInt(paramCount++, tranType);
			}
			if (0 != tranId) {
				ps.setInt(paramCount++, tranId);
			}
			if (startDt != null && !startDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						startDt).getTime()));
			}
			if (endDt != null && !endDt.equals("")) {
				ps.setDate(paramCount++, new java.sql.Date(Utility.getDate(
						endDt).getTime()));
			}
			ps.setLong(paramCount++, parentId);
			/** execute the query */
			rs = ps.executeQuery();

			/** iterate the resultset */
			while (rs.next()) {
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));

				// Send the Transaction Status ordinal value instead of constant
				// charachers.
				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));
				/*
				 * if (TransactionStatus.SUCCESS.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_SUCCESS); } else if
				 * (TransactionStatus.PENDING.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_IN_PROGRESS); } else if
				 * (TransactionStatus.FAILURE.getValue() == rs
				 * .getInt("TRANS_STATUS")) { customerTransaction
				 * .setStatus(Constants.TRANSACTION_FAILURE); }
				 */
				customerTransaction.setReason(rs.getString("REASON_ID"));
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"), ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				logger.info("validity : " + validity);
				customerTransaction.setValidity(validity);
				customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
				

				String message = rs.getString("DETAIL_MSG");
				double serviceTax = Utility.parseMessage(message, Constants.REPORT_SERVICE_TAX_START);
				logger.info("serviceTax : " + serviceTax);
				customerTransaction.setServiceTax(serviceTax);
				
				double espCommission = Utility.parseMessage(message, Constants.REPORT_ESP_COMMISSION_START);
				logger.info("espCommission : " + espCommission);
				customerTransaction.setEspCommission(espCommission);

				double processingFee = Utility.parseMessage(message, Constants.REPORT_PROCESSING_FEE_START);
				logger.info("processingFee : " + processingFee);
				customerTransaction.setProcessingFee(processingFee);

				double talkTime = Utility.parseMessage(message, Constants.REPORT_TALK_TIME_START);
				logger.info("talkTime : " + talkTime);
				customerTransaction.setTalkTime(talkTime);

				/** adding each DTO object into array List */
				results.add(customerTransaction);
			}
		} catch (SQLException e) {
			logger
					.fatal(
							"Exception occured while reteriving all customer transaction list for external user logged in. "
									+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} catch(VirtualizationServiceException virtualizationExp){
			logger.error("DistributorTransactionDaoRdbms:caught VirtualizationServiceException"+virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		} finally {
			/** Close the preparedstatement,resultset. */
			DBConnectionManager.releaseResources(ps, rs);
		}

		logger
				.info("Executed getCustomerChildAccountListAll().... All Customer child Transaction List SuccessFully Retreived");
		return results;
	}

	/*
	 * (non-Javadoc)
	 * @see com.ibm.virtualization.recharge.dao.ReportDao#getCustomerTransactionRptList(com.ibm.virtualization.recharge.dto.ReportInputs, int, int, boolean, java.lang.String)
	 */
	public ArrayList getCustomerTransactionRptList(ReportInputs mtDTO,
			int lowerBound, int upperBound, boolean isExport, String transId)
			throws DAOException {
		logger.debug("Inside getCustomerTransactionRptList()...mobileNO="+mtDTO.getMobileNo());
		// String status = mtDTO.getStatus();

		// PreparedStatement ps = null;
		ResultSet rs = null;
		CustomerTransaction customerTransaction = null;
		ArrayList<CustomerTransaction> transactionList = new ArrayList<CustomerTransaction>();
         
		try { 
 
			List<Object> params = new ArrayList<Object>();
			StringBuilder strSql = new StringBuilder();

			strSql = buildCustomerTransactionReportQuery(mtDTO, params,
					lowerBound, upperBound, isExport, transId);

			rs = execute(strSql.toString(), params);

			while (rs.next()) {
				logger.info(" ");
				customerTransaction = new CustomerTransaction();
				customerTransaction.setTransactionId(rs.getLong("TRANS_ID"));
				customerTransaction.setSourceAccountCode(rs
						.getString("LOGIN_NAME"));
				customerTransaction.setCustomerMobileNo(rs
						.getString("RECEIVER_ID"));
				customerTransaction.setTransactionAmount(rs
						.getDouble("TRANS_AMOUNT"));
				customerTransaction.setTransactionDate(rs
						.getTimestamp("TRANS_DATE"));

				customerTransaction.setStatus(String.valueOf(rs
						.getInt("TRANS_STATUS")));

				String inStatus = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_IN_STATUS));
		        customerTransaction.setInStatus(inStatus);

				customerTransaction.setReason(rs.getString("REASON_ID"));
				customerTransaction.setTotalRecords(rs.getInt("RECORD_COUNT"));

				if (!isExport) {
					customerTransaction.setRowNum(rs.getString("RNUM"));
				}
				customerTransaction.setTransationType((TransactionType
						.getTransactionType(rs.getInt("TRANS_TYPE"))).name());
				


				if (isExport) {
					String message = rs.getString("DETAIL_MSG");
					
					String confirmMobileNo = Utility.parseMessageString(message, Constants.REPORT_CONFIRM_MOBILE_NUMBER);
					logger.info("confirmMobileNo " +confirmMobileNo);
					customerTransaction.setConfirmMobileNo(confirmMobileNo);
					
					double serviceTax = Utility.parseMessage(message,
								Constants.REPORT_SERVICE_TAX_START);
					logger.info("serviceTax : " + serviceTax);
					customerTransaction.setServiceTax(serviceTax);

					double espCommission = Utility.parseMessage(message,
									Constants.REPORT_ESP_COMMISSION_START);
					logger.info("espCommission : " + espCommission);
					customerTransaction.setEspCommission(espCommission);

					double processingFee = Utility.parseMessage(message,
									Constants.REPORT_PROCESSING_FEE_START);
					logger.info("processingFee : " + processingFee);
					customerTransaction.setProcessingFee(processingFee);

					/*String validity = Utility.parseMessageString(message,
							ResourceReader.getWebResourceBundle().getString(
									Constants.REPORT_VALIDITY_XML));
					logger.info("validity : " + validity);*/
					

					double talkTime = Utility.parseMessage(message,
								Constants.REPORT_TALK_TIME_START);
					logger.info("talkTime : " + talkTime);
					customerTransaction.setTalkTime(talkTime);
				}
				String validity = Utility.parseMessageString(rs.getString("THIRD_PARTY"),
						ResourceReader.getWebResourceBundleValue(Constants.REPORT_VALIDITY_XML));
				customerTransaction.setValidity(validity);
		        logger.debug("Validity : " + validity);
				
				transactionList.add(customerTransaction);
			}

		} catch (SQLException e) {
			logger.error("Exception occured while reteriving List"
					+ "Exception Message: ", e);
			throw new DAOException(ExceptionCode.ERROR_DB_INTERNAL);
		} catch (VirtualizationServiceException virtualizationExp) {
			logger
					.error("DistributorTransactionDaoRdbmsDB2:caught VirtualizationServiceException"
							+ virtualizationExp.getMessage());
			throw new DAOException(virtualizationExp.getMessage());
		} finally {
			// Close the statement,resultset for success or failure transactions
			try {
				if (rs != null) {
					rs.close();
				}
			} catch (SQLException sqlException) {
				logger.error(
						"  Could Not Close ResultSet and Statement. Reason:"
								+ sqlException.getMessage() + ". Error Code:"
								+ sqlException.getErrorCode(), sqlException);
			}

		}
		logger.debug("Executed getTransactionRptList()...");
		return transactionList;
	}
	
	
	
	
	/*
	 * this function is use to  make a query for getting  Customer transaction  report data 
	 */
	private StringBuilder buildCustomerTransactionReportQuery(
			ReportInputs mtDTO, List<Object> params, int lowerBound,
			int upperBound, boolean isExport, String transId) {
		// get the data from  the input DTO 

		int circleId = mtDTO.getCircleId();
		String startDt = mtDTO.getStartDt();
		String endDt = mtDTO.getEndDt();
		UserSessionContext ctx = mtDTO.getSessionContext();
		StringBuilder sql = new StringBuilder();
		logger.info(" mtDTO "+mtDTO.getRequestType());
		if (!isExport) {
			sql
					.append("SELECT * from(select a.*,ROW_NUMBER() over() rnum FROM (");
		}

		if (!isExport) {
			sql.append(queryMap.get(SQL_CUST_TRANSACTION_REPORT_DATA_KEY));
			sql.append(queryMap
					.get(SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_KEY));
		} else {
			sql.append(queryMap
					.get(SQL_CUST_TRANSACTION_REPORT_DATA_EXPORT_KEY));
			sql.append(queryMap
					.get(SQL_CUST_TRANSACTION_REPORT_WHERE_CLAUSE_EXPORT_KEY));

			if (isExport) {
				if (mtDTO.getRequestType() != null) {
					if (mtDTO.getRequestType().getValue() == RequestType.RECHARGE
							.ordinal()) {
						sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
								TransactionState.RECHARGE_REQUEST_LISTENER
										.getValue());
					} else if (mtDTO.getRequestType().getValue() == RequestType.POSTPAID_MOBILE
							.ordinal()
							|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_ABTS
									.ordinal()
							|| mtDTO.getRequestType().getValue() == RequestType.POSTPAID_DTH
									.ordinal()) {
						sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
								TransactionState.POSTPAID_REQUEST_LISTENER
										.getValue());
					} else if (mtDTO.getRequestType().getValue() == RequestType.VAS
							.ordinal()) {
						sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
								TransactionState.VAS_REQUEST_LISTENER
										.getValue());

					}// else if Request Type is VAS

					// , append TransactionState accordingly
					
				}
				//TODO bhanu: this only for recharge,for VAS and Post-Paid we Need to append all states(post paid,recharge,vas)
				// in or condition in query 
				if ((transId != null) && (!transId.equalsIgnoreCase(""))) {
					sql.append(" AND ( TDETAIL.TRANS_STATE = ").append(
							TransactionState.RECHARGE_REQUEST_LISTENER
									.getValue());
					sql.append(" OR TDETAIL.TRANS_STATE = ").append(TransactionState.POSTPAID_REQUEST_LISTENER.getValue());
					sql.append(" OR TDETAIL.TRANS_STATE = ").append(TransactionState.VAS_REQUEST_LISTENER.getValue());
				}
				sql.append(" OR TDETAIL.TRANS_STATE = ").append(
						TransactionState.WEB.getValue()).append(" ) ");
			}

		}

		if (transId == null || transId.equalsIgnoreCase("")) {
			sql
					.append("AND  DATE(TRANS.CREATED_DATE) >= ? AND DATE(TRANS.CREATED_DATE) <= ? AND TRANS_TYPE = ? ");
			params.add(Utility.getSqlDate(startDt));
			params.add(Utility.getSqlDate(endDt));
			params.add(Integer.valueOf(mtDTO.getRequestType().getValue()));
		}

		if ((transId != null) && (!transId.equalsIgnoreCase(""))) {
			sql.append("AND TRANS.TRANS_ID =? ");
			params.add(Long.valueOf(transId));
		}
		// Condition for Customer Mobile No 
		if ((mtDTO.getMobileNo() != null) && (!mtDTO.getMobileNo().equalsIgnoreCase(""))) {
			sql.append("AND TRANS.RECEIVER_ID =? ");
			params.add(mtDTO.getMobileNo());
		}
		

//		if (circleId != 0) {
//			// if circle user
//			sql
//					.append(queryMap
//							.get(SQL_FETCH_VIEW_CUST_TRAN_WHERE_CLAUSE_CIRCLEUSER_KEY));
//			params.add(Integer.valueOf(circleId));
//		}

		// search according to parent account
		if (Constants.USER_TYPE_EXTERNAL.equalsIgnoreCase(ctx.getType())) {
			sql.append(queryMap
					.get(SQL_FETCH_CUST_TRAN_WHERE_CLAUSE_EXT_USERS_KEY));
			params.add(Long.valueOf(ctx.getId()));
		}
		sql.append(" ORDER BY TRANS.TRANS_ID DESC");
		if (!isExport) {
			sql.append(") a)b Where rnum<=? AND rnum>=?");
			params.add(upperBound);
			params.add(lowerBound + 1);
		}

		logger.debug(" this is the SQL for Successfull transaction :---- "
				+ sql.toString());

		logger.info("sql=" + sql.toString());
		return sql;

	}

	

	

}
